.. index:: Scene

.. _l5363656e65:

Scene PT
========

:viewcode:`scene.spad line 3994 <scene.spad#L3994>` :editcode:`[edit on github] <scene.spad#L3994>`

* PT: \ :ref:`SPointCategory <l53506f696e7443617465676f7279>`\ 


these are the parameters that can be set for nodes of various types


.. _l5363656e65-6164644172726f77733244696e3244:

.. index::
   pair: Scene; addArrows2Din2D

:spadfun:`addArrows2Din2D`\: (%, PT -> PT, \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``addArrows2Din2D(n, ptFun, uSeg, vSeg, numPts)``\  is a convenience function which combines createArrows2Din2D with addChild!

.. _l5363656e65-6164644368696c6421:

.. index::
   pair: Scene; addChild!

:spadfun:`addChild!`\: (%, %) -> \ :ref:`Void <l566f6964>`\  
  \ ``addChild!(n, c)``\  adds the specified child node \ ``'c'``\  below node \ ``'n'``\ 

.. _l5363656e65-616464506c6f743144696e3244:

.. index::
   pair: Scene; addPlot1Din2D

:spadfun:`addPlot1Din2D`\: (%, \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\  -> \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``addPlot1Din2D(n, f, tRange, numPts)``\  is a convenience function which combines createPlot1Din2D with addChild!


.. index::
   pair: Scene; addPlot1Din2D

:spadfun:`addPlot1Din2D`\: (%, \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\  -> PT, \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``addPlot1Din2D(n, f, tRange, numPts)``\  is a convenience function which combines createPlot1Din2D with addChild!

.. _l5363656e65-616464506c6f743144696e3244706172616d6574726963:

.. index::
   pair: Scene; addPlot1Din2Dparametric

:spadfun:`addPlot1Din2Dparametric`\: (%, \ :ref:`ParametricPlaneCurve <l506172616d6574726963506c616e654375727665>`\ (\ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\  -> \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ), \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``addPlot1Din2Dparametric(n, ppc, tRange, numPts)``\  is a convenience function which combines createPlot1Din2Dparametric with addChild!

.. _l5363656e65-616464506c6f743144696e3344706172616d6574726963:

.. index::
   pair: Scene; addPlot1Din3Dparametric

:spadfun:`addPlot1Din3Dparametric`\: (%, \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\  -> PT, \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``addPlot1Din3Dparametric(n, pcfun, tRange, numPts)``\  is a convenience function which combines createPlot1Din3Dparametric with addChild!


.. index::
   pair: Scene; addPlot1Din3Dparametric

:spadfun:`addPlot1Din3Dparametric`\: (%, \ :ref:`ParametricSpaceCurve <l506172616d657472696353706163654375727665>`\ (\ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\  -> \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ), \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``addPlot1Din3Dparametric(n, psc, tRange, numPts)``\  is a convenience function which combines createPlot1Din3Dparametric with addChild!

.. _l5363656e65-616464506c6f743244696e3344:

.. index::
   pair: Scene; addPlot2Din3D

:spadfun:`addPlot2Din3D`\: (%, (\ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ) -> \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``addPlot2Din3D(n, f, uSeg, vSeg, numPts)``\  is a convenience function which combines createPlot2Din3D with addChild!

.. _l5363656e65-616464506c6f743244696e3344706172616d6574726963:

.. index::
   pair: Scene; addPlot2Din3Dparametric

:spadfun:`addPlot2Din3Dparametric`\: (%, (\ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ) -> PT, \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``addPlot2Din3Dparametric(n, f, uSeg, vSeg, numPts)``\  is a convenience function which combines createPlot2Din3Dparametric with addChild!


.. index::
   pair: Scene; addPlot2Din3Dparametric

:spadfun:`addPlot2Din3Dparametric`\: (%, \ :ref:`ParametricSurface <l506172616d657472696353757266616365>`\ ((\ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ) -> \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ), \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``addPlot2Din3Dparametric(n, f, uSeg, vSeg, numPts)``\  is a convenience function which combines createPlot2Din3Dparametric with addChild!

.. _l5363656e65-6164645363656e654172726f77:

.. index::
   pair: Scene; addSceneArrow

:spadfun:`addSceneArrow`\: (%, %, %, PT, \ :ref:`Symbol <l53796d626f6c>`\ , \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ) -> % 
  \ ``addSceneArrow(n, st, en, offset, mode, size, fontScale)``\  is a convenience function which combines createSceneArrow with addChild!


.. index::
   pair: Scene; addSceneArrow

:spadfun:`addSceneArrow`\: (%, \ :ref:`String <l537472696e67>`\ , \ :ref:`String <l537472696e67>`\ , PT, \ :ref:`Symbol <l53796d626f6c>`\ , \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ) -> % 
  \ ``addSceneArrow(n, st, en, offset, mode, size)``\  is a convenience function which combines createSceneArrow with addChild!

.. _l5363656e65-6164645363656e654172726f7773:

.. index::
   pair: Scene; addSceneArrows

:spadfun:`addSceneArrows`\: (%, \ :ref:`List <l4c697374>`\  \ :ref:`List <l4c697374>`\  PT, \ :ref:`Symbol <l53796d626f6c>`\ , \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ) -> % 
  \ ``addSceneArrows(n, line, mode, size)``\  is a convenience function which combines createSceneArrows with addChild!

.. _l5363656e65-6164645363656e65426f78:

.. index::
   pair: Scene; addSceneBox

:spadfun:`addSceneBox`\: (%, \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ) -> % 
  \ ``addSceneBox(n, size)``\  is a convenience function which combines createSceneBox with addChild!

.. _l5363656e65-6164645363656e65436c6970:

.. index::
   pair: Scene; addSceneClip

:spadfun:`addSceneClip`\: (%, \ :ref:`SBoundary <l53426f756e64617279>`\  PT) -> % 
  \ ``addSceneClip(n, bb)``\  is a convenience function which combines createSceneClip with addChild!

.. _l5363656e65-6164645363656e65446566:

.. index::
   pair: Scene; addSceneDef

:spadfun:`addSceneDef`\: (%, \ :ref:`String <l537472696e67>`\ , %) -> % 
  \ ``addSceneDef(n, nam, nde)``\  is a convenience function which combines createSceneDef with addChild!

.. _l5363656e65-6164645363656e654772617068:

.. index::
   pair: Scene; addSceneGraph

:spadfun:`addSceneGraph`\: (%, \ :ref:`DirectedGraph <l44697265637465644772617068>`\  \ :ref:`String <l537472696e67>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`Boolean <l426f6f6c65616e>`\ ) -> % 
  \ ``addSceneGraph(n, g, x, y, dispArrowName)``\  is a convenience function which combines createSceneGraph with addChild!

.. _l5363656e65-6164645363656e6547726964:

.. index::
   pair: Scene; addSceneGrid

:spadfun:`addSceneGrid`\: (%, \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`SBoundary <l53426f756e64617279>`\  PT) -> % 
  \ ``addSceneGrid(n, stepSize, bb)``\  is a convenience function which combines createSceneGrid with addChild!


.. index::
   pair: Scene; addSceneGrid

:spadfun:`addSceneGrid`\: (%, \ :ref:`SBoundary <l53426f756e64617279>`\  PT) -> % 
  \ ``addSceneGrid(n, bb)``\  is a convenience function which combines createSceneGrid with addChild!

.. _l5363656e65-6164645363656e6547726f7570:

.. index::
   pair: Scene; addSceneGroup

:spadfun:`addSceneGroup`\: % -> % 
  \ ``addSceneGroup(n)``\  is a convenience function which combines createSceneGroup with addChild!

.. _l5363656e65-6164645363656e65494653:

.. index::
   pair: Scene; addSceneIFS

:spadfun:`addSceneIFS`\: (%, \ :ref:`List <l4c697374>`\  \ :ref:`List <l4c697374>`\  \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`List <l4c697374>`\  PT) -> % 
  \ ``addSceneIFS(n, inx, pts)``\  is a convenience function which combines createSceneIFS with addChild!


.. index::
   pair: Scene; addSceneIFS

:spadfun:`addSceneIFS`\: (%, \ :ref:`SceneIFS <l5363656e65494653>`\  PT) -> % 
  \ ``addSceneIFS(n, in1)``\  is a convenience function which combines createSceneIFS with addChild!

.. _l5363656e65-6164645363656e654c696e65:

.. index::
   pair: Scene; addSceneLine

:spadfun:`addSceneLine`\: (%, %, %, \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ) -> % 
  \ ``addSceneLine(n, st, en, fontScale)``\  is a convenience function which combines createSceneLine with addChild!


.. index::
   pair: Scene; addSceneLine

:spadfun:`addSceneLine`\: (%, %, %, \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`Boolean <l426f6f6c65616e>`\ ) -> % 
  \ ``addSceneLine(n, st, en, fontScale)``\  is a convenience function which combines createSceneLine with addChild!


.. index::
   pair: Scene; addSceneLine

:spadfun:`addSceneLine`\: (%, \ :ref:`List <l4c697374>`\  PT) -> % 
  \ ``addSceneLine(n, line)``\  is a convenience function which combines createSceneLine with addChild!

.. _l5363656e65-6164645363656e654c696e6573:

.. index::
   pair: Scene; addSceneLines

:spadfun:`addSceneLines`\: (%, \ :ref:`List <l4c697374>`\  \ :ref:`List <l4c697374>`\  PT) -> % 
  \ ``addSceneLines(n, line)``\  is a convenience function which combines createSceneLines with addChild!

.. _l5363656e65-6164645363656e654d6174657269616c:

.. index::
   pair: Scene; addSceneMaterial

:spadfun:`addSceneMaterial`\: (%, \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`String <l537472696e67>`\ , \ :ref:`String <l537472696e67>`\ ) -> % 
  \ ``addSceneMaterial(n, lineW, lineC, fillC)``\  is a convenience function which combines createSceneMaterial with addChild!


.. index::
   pair: Scene; addSceneMaterial

:spadfun:`addSceneMaterial`\: (%, Record(lineWidth: \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , lineCol: \ :ref:`String <l537472696e67>`\ , fillCol: \ :ref:`String <l537472696e67>`\ , matOpacity: \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ )) -> % 
  \ ``addSceneMaterial(n, mat)``\  is a convenience function which combines createSceneMaterial with addChild!

.. _l5363656e65-6164645363656e654e616d6564506f696e7473:

.. index::
   pair: Scene; addSceneNamedPoints

:spadfun:`addSceneNamedPoints`\: (%, \ :ref:`SceneNamedPoints <l5363656e654e616d6564506f696e7473>`\  PT) -> % 
  \ ``addSceneNamedPoints(n, np)``\  is a convenience function which combines createSceneNamedPoints with addChild!

.. _l5363656e65-6164645363656e655061747465726e:

.. index::
   pair: Scene; addScenePattern

:spadfun:`addScenePattern`\: (%, \ :ref:`Symbol <l53796d626f6c>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`SBoundary <l53426f756e64617279>`\  PT) -> % 
  \ ``addScenePattern(n, ptype, step, bb)``\  is a convenience function which combines createScenePattern with addChild!

.. _l5363656e65-6164645363656e6552756c6572:

.. index::
   pair: Scene; addSceneRuler

:spadfun:`addSceneRuler`\: (%, \ :ref:`Symbol <l53796d626f6c>`\ , PT, \ :ref:`SBoundary <l53426f756e64617279>`\  PT) -> % 
  \ ``addSceneRuler(n, ptype, offset, bb)``\  is a convenience function which combines createSceneRuler with addChild!

.. _l5363656e65-6164645363656e655368617065:

.. index::
   pair: Scene; addSceneShape

:spadfun:`addSceneShape`\: (%, Record(shptype: \ :ref:`Symbol <l53796d626f6c>`\ , centre: PT, size: PT, fill: \ :ref:`Boolean <l426f6f6c65616e>`\ )) -> % 
  \ ``addSceneShape(n, shape)``\  is a convenience function which combines createSceneShape with addChild!


.. index::
   pair: Scene; addSceneShape

:spadfun:`addSceneShape`\: (%, \ :ref:`SBoundary <l53426f756e64617279>`\  PT) -> % 
  \ ``addSceneShape(n, shape)``\  is a convenience function which combines createSceneShape with addChild!

.. _l5363656e65-6164645363656e6554657874:

.. index::
   pair: Scene; addSceneText

:spadfun:`addSceneText`\: (%, \ :ref:`List <l4c697374>`\  \ :ref:`String <l537472696e67>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , PT) -> % 
  \ ``addSceneText(n, str, sz, pz)``\  is a convenience function which combines createSceneText with addChild!


.. index::
   pair: Scene; addSceneText

:spadfun:`addSceneText`\: (%, Record(txt: \ :ref:`String <l537472696e67>`\ , siz: \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , pos: PT, np: \ :ref:`List <l4c697374>`\  \ :ref:`String <l537472696e67>`\ )) -> % 
  \ ``addSceneText(n, text)``\  is a convenience function which combines createSceneText with addChild!


.. index::
   pair: Scene; addSceneText

:spadfun:`addSceneText`\: (%, \ :ref:`String <l537472696e67>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , PT) -> % 
  \ ``addSceneText(n, str, sz, pz)``\  is a convenience function which combines createSceneText with addChild!

.. _l5363656e65-6164645363656e655472616e73666f726d:

.. index::
   pair: Scene; addSceneTransform

:spadfun:`addSceneTransform`\: (%, \ :ref:`STransform <l535472616e73666f726d>`\  PT) -> % 
  \ ``addSceneTransform(n, tran)``\  is a convenience function which combines createSceneTransform with addChild!

.. _l5363656e65-6164645363656e65557365:

.. index::
   pair: Scene; addSceneUse

:spadfun:`addSceneUse`\: (%, \ :ref:`String <l537472696e67>`\ ) -> % 
  \ ``addSceneUse(n, nam)``\  is a convenience function which combines createSceneUse with addChild!

.. _l5363656e65-626f756e64617279:

.. index::
   pair: Scene; boundary

:spadfun:`boundary`\: (%, \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ) -> \ :ref:`SBoundary <l53426f756e64617279>`\  PT 
  \ ``boundary(n, fontScale)``\  returns the boundary of a given node, so if this is called on the root node, it will return the boundary of the whole scene. There is a difficulty involving text nodes, that is they have a fixed font size. But we want to calculate the boundary in local coordinates, to do this conversion we need to know the total boundary size but that is what we are trying to calculate! To get round this contradiction the parameter fontScale is required since fonts are rendered at a fixed size we need a scaling factor so that we can give the boundary in our coordinate system. fontScale should be set to the full width of the diagram (not just the width of this node). If this is not known then choose an approximate value. This only affects text nodes, if this node, or its subnodes, do not contain a text node then its value is not significant.

.. _l5363656e65-636f65726365:

.. index::
   pair: Scene; coerce

:spadfun:`coerce`\: % -> \ :ref:`OutputForm <l4f7574707574466f726d>`\  
  output a full scenegraph could contain a lot of data and so we have to be careful to restrict the output to what is reasonable on the command line. Therefore we do not display all subnodes or the full information from nodes such as IFS.

.. _l5363656e65-6372656174654172726f77733244696e3244:

.. index::
   pair: Scene; createArrows2Din2D

:spadfun:`createArrows2Din2D`\: (PT -> PT, \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``createArrows2Din2D(ptFun, uSeg, vSeg, numPts)``\  creates arrows to represent output for each input point in other words this represents a two dimensional force field with the arrows showing the direction of the field

.. _l5363656e65-637265617465506c6f743144696e3244:

.. index::
   pair: Scene; createPlot1Din2D

:spadfun:`createPlot1Din2D`\: (\ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\  -> \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``createPlot1Din2D(f, tRange, numPts)``\  creates two dimensional function plot. Draws the graph of \ ``y``\  = \ ``f``\ (\ ``x``\ ) as \ ``x``\  ranges from min(a, \ ``b``\ ) to max(a, \ ``b``\ ). \ ``tRange``\  is a..\ ``b``\ 


.. index::
   pair: Scene; createPlot1Din2D

:spadfun:`createPlot1Din2D`\: (\ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\  -> PT, \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``createPlot1Din2D(f, tRange, numPts)``\  creates a two dimensional function plot draws the graph from a mapping of float to point as \ ``x``\  ranges from min(a, \ ``b``\ ) to max(a, \ ``b``\ ). \ ``tRange``\  is a..\ ``b``\ 

.. _l5363656e65-637265617465506c6f743144696e3244706172616d6574726963:

.. index::
   pair: Scene; createPlot1Din2Dparametric

:spadfun:`createPlot1Din2Dparametric`\: (\ :ref:`ParametricPlaneCurve <l506172616d6574726963506c616e654375727665>`\ (\ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\  -> \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ), \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``createPlot1Din2Dparametric(ppc, tRange, numPts)``\  creates a node from plot using Parametric Plane Curve. This represents 1 dimension (line - possibly curved) in 2 dimensions (plane) In theory a line has no width but in that case we would not see it so we give it a width given by the material node that is applicable in this part of the scene graph \ ``PPC``\  is ParametricPlaneCurve(\ ``DF``\  \ ``->``\  \ ``DF``\ ) which is created with curve(\ ``f1``\ , \ ``f2``\ ) where \ ``f1``\  and \ ``f2``\  are functions of type ComponentFunction, in this case \ ``DF``\  \ ``->``\  \ ``DF``\ 

.. _l5363656e65-637265617465506c6f743144696e3344706172616d6574726963:

.. index::
   pair: Scene; createPlot1Din3Dparametric

:spadfun:`createPlot1Din3Dparametric`\: (\ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\  -> PT, \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``createPlot1Din3Dparametric(pcfun, tRange, numPts)``\  create a line (1D subspace) in 3D space. This represents 1 dimension (line - possibly curved) in 3 dimensions In theory a line has no width but in that case we would not see it so we give it a width given by the material node that is applicable in this part of the scene graph PCFUN is a function from float to point: \ ``DF``\  \ ``->``\  \ ``PT``\ 


.. index::
   pair: Scene; createPlot1Din3Dparametric

:spadfun:`createPlot1Din3Dparametric`\: (\ :ref:`ParametricSpaceCurve <l506172616d657472696353706163654375727665>`\ (\ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\  -> \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ), \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``createPlot1Din3Dparametric(psc, tRange, numPts)``\  create a line (1D subspace) in 3D space. This represents 1 dimension (line - possibly curved) in 3 dimensions In theory a line has no width but in that case we would not see it so we give it a width given by the material node that is applicable in this part of the scene graph \ ``PSC``\  ParametricSpaceCurve(\ ``DF``\  \ ``->``\  \ ``DF``\ ) is created with curve(\ ``f1``\ , \ ``f2``\ , \ ``f3``\ ) where \ ``f1``\ , \ ``f2``\  and \ ``f3``\  are functions of type ComponentFunction, in this case \ ``DF``\  \ ``->``\  \ ``DF``\ 

.. _l5363656e65-637265617465506c6f743244696e3344:

.. index::
   pair: Scene; createPlot2Din3D

:spadfun:`createPlot2Din3D`\: ((\ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ) -> \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``createPlot2Din3D(f, a..b, c..d)``\  returns a scene node which contains the graph of \ ``z``\  = \ ``f``\ (\ ``x``\ , \ ``y``\ ) as \ ``x``\  ranges from min(a, \ ``b``\ ) to max(a, \ ``b``\ ) and \ ``y``\  ranges from min(\ ``c``\ , \ ``d``\ ) to max(\ ``c``\ , \ ``d``\ ). create a surface (2D subspace) in 3D space The surface is approximated by polygons which are represented by in indexed face set (IFS) node


.. index::
   pair: Scene; createPlot2Din3D

:spadfun:`createPlot2Din3D`\: ((\ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ) -> PT, \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``createPlot2Din3D(ptFun, uSeg, vSeg, numPts)``\  create a surface (2D subspace) in 3D space. The surface is approximated by polygons which are represented by in indexed face set (IFS) node

.. _l5363656e65-637265617465506c6f743244696e3344706172616d6574726963:

.. index::
   pair: Scene; createPlot2Din3Dparametric

:spadfun:`createPlot2Din3Dparametric`\: ((\ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ) -> PT, \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``createPlot2Din3Dparametric(f, a..b, c..d, l)``\  returns a scene node which contains the graph of the parametric surface \ ``f``\ (\ ``u``\ , \ ``v``\ ) as \ ``u``\  ranges from min(a, \ ``b``\ ) to max(a, \ ``b``\ ) and \ ``v``\  ranges from min(\ ``c``\ , \ ``d``\ ) to max(\ ``c``\ , \ ``d``\ ). This creates a surface (2D subspace) in 3D space The surface is approximated by polygons which are represented by in indexed face set (IFS) node


.. index::
   pair: Scene; createPlot2Din3Dparametric

:spadfun:`createPlot2Din3Dparametric`\: (\ :ref:`ParametricSurface <l506172616d657472696353757266616365>`\ ((\ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ) -> \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ), \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`Segment <l5365676d656e74>`\  \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``createPlot2Din3Dparametric(surface(f, g, h), a..b, c..d, l)``\  returns a scene node which contains the graph of the parametric surface \ ``x``\  = \ ``f``\ (\ ``u``\ , \ ``v``\ ), \ ``y``\  = \ ``g``\ (\ ``u``\ , \ ``v``\ ), \ ``z``\  = \ ``h``\ (\ ``u``\ , \ ``v``\ ) as \ ``u``\  ranges from min(a, \ ``b``\ ) to max(a, \ ``b``\ ) and \ ``v``\  ranges from min(\ ``c``\ , \ ``d``\ ) to max(\ ``c``\ , \ ``d``\ ). This creates a surface (2D subspace) in 3D space The surface is approximated by polygons which are represented by in indexed face set (IFS) node

.. _l5363656e65-6372656174655363656e654172726f77:

.. index::
   pair: Scene; createSceneArrow

:spadfun:`createSceneArrow`\: (%, %, PT, \ :ref:`Symbol <l53796d626f6c>`\ , \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ) -> % 
  \ ``createSceneArrow(st, en, offset, mode, size, fontScale)``\  constructs an arrow node, in \ ``n``\ -dimensional space, going from \ ``st``\  to \ ``en``\ . 'st' and 'en' are nodes in the scene and the arrows will be drawn upto their boundary. \ ``st``\  is the node at the start of the arrow \ ``en``\  is the node at the end of the arrow 'mode' and 'size' parameters determine the \ ``size``\  of the arrowhead. \ ``mode``\  can have the following values: "fixed"::Symbol \ ``--``\  fixed \ ``size``\  line width given by 'size' parameter "proportional"::Symbol \ ``--``\  \ ``size``\  as a proportion of the overall bounds "variable"::Symbol \ ``--``\  \ ``size``\  as a proportion of the arrow length So "proportional" would typically be used when drawing a graph (in graph theory) where it looks better if each arrow head is the same. "variable" would typically be used when drawing a force field where a bigger arrow head might indicate a stronger force. fontScale should be set to the full width of the diagram (not just the width of this node). If this is not known then choose an approximate value. This only affects text nodes, if \ ``st``\  or \ ``en``\ , or its subnodes, do not contain a text node then its value is not significant.


.. index::
   pair: Scene; createSceneArrow

:spadfun:`createSceneArrow`\: (\ :ref:`String <l537472696e67>`\ , \ :ref:`String <l537472696e67>`\ , PT, \ :ref:`Symbol <l53796d626f6c>`\ , \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ) -> % 
  \ ``createSceneArrow(st, en, offset, mode, size)``\  constructs an arrow node, in \ ``n``\ -dimensional space, going from \ ``st``\  to \ ``en``\ . 'st' and 'en' are determined from a list of points from named points node. \ ``st``\  is the start of the arrow \ ``en``\  is the end of the arrow 'mode' and 'size' parameters determine the size of the arrowhead. \ ``mode``\  can have the following values: "fixed"::Symbol \ ``--``\  fixed size line width given by 'size' parameter "proportional"::Symbol \ ``--``\  size as a proportion of the overall bounds "variable"::Symbol \ ``--``\  size as a proportion of the arrow length So "proportional" would typically be used when drawing a graph (in graph theory) where it looks better if each arrow head is the same. "variable" would typically be used when drawing a force field where a bigger arrow head might indicate a stronger force.

.. _l5363656e65-6372656174655363656e654172726f7773:

.. index::
   pair: Scene; createSceneArrows

:spadfun:`createSceneArrows`\: (\ :ref:`List <l4c697374>`\  \ :ref:`List <l4c697374>`\  PT, \ :ref:`Symbol <l53796d626f6c>`\ , \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ) -> % 
  \ ``createSceneArrows(line, mode, size)``\  constructs an arrow node, this contains arrows (represented by a list of points) in \ ``n``\ -dimensional space. The space is implicit in the \ ``PT``\  and \ ``TR``\  parameters supplied when this Scene was created. 'mode' and 'size' parameters determine the size of the arrowhead. \ ``mode``\  can have the following values: "fixed"::Symbol \ ``--``\  fixed size \ ``line``\  width given by 'size' parameter "proportional"::Symbol \ ``--``\  size as a proportion of the overall bounds "variable"::Symbol \ ``--``\  size as a proportion of the arrow length So "proportional" would typically be used when drawing a graph (in graph theory) where it looks better if each arrow head is the same. "variable" would typically be used when drawing a force field where a bigger arrow head might indicate a stronger force.

.. _l5363656e65-6372656174655363656e65426f78:

.. index::
   pair: Scene; createSceneBox

:spadfun:`createSceneBox`\: \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\  -> % 
  \ ``createSceneBox(size)``\  constructs an indexed face set node which is a 3D box of a given \ ``size``\ 

.. _l5363656e65-6372656174655363656e65436c6970:

.. index::
   pair: Scene; createSceneClip

:spadfun:`createSceneClip`\: \ :ref:`SBoundary <l53426f756e64617279>`\  PT -> % 
  \ ``createSceneClip(bb)``\  constructs a clip node, clips its sub nodes in the coordinate system in force at the clip node.

.. _l5363656e65-6372656174655363656e65446566:

.. index::
   pair: Scene; createSceneDef

:spadfun:`createSceneDef`\: (\ :ref:`String <l537472696e67>`\ , %) -> % 
  \ ``createSceneDef(nam, nde)``\  defines a point in the scenegraph so that it can be used elsewhere.

.. _l5363656e65-6372656174655363656e654772617068:

.. index::
   pair: Scene; createSceneGraph

:spadfun:`createSceneGraph`\: (\ :ref:`DirectedGraph <l44697265637465644772617068>`\  \ :ref:`String <l537472696e67>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`Boolean <l426f6f6c65616e>`\ ) -> % 
  \ ``createSceneGraph(g, x, y, dispArrowName)``\  creates a graph theory diagram

.. _l5363656e65-6372656174655363656e6547726964:

.. index::
   pair: Scene; createSceneGrid

:spadfun:`createSceneGrid`\: (\ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`SBoundary <l53426f756e64617279>`\  PT) -> % 
  \ ``createSceneGrid(stepSize, bb)``\  constructs a grid, consists of a group, under which are vertical and horizontal lines. The spacing between lines is given by step.


.. index::
   pair: Scene; createSceneGrid

:spadfun:`createSceneGrid`\: \ :ref:`SBoundary <l53426f756e64617279>`\  PT -> % 
  \ ``createSceneGrid(bb)``\  constructs a grid with narrow blue lines every 20 units wide blue lines every 100 units wide red lines every 200 units

.. _l5363656e65-6372656174655363656e6547726f7570:

.. index::
   pair: Scene; createSceneGroup

:spadfun:`createSceneGroup`\: () -> % 
  \ ``createSceneGroup()``\  constructs a group node, this node does not do anything itself but contains other nodes

.. _l5363656e65-6372656174655363656e65494653:

.. index::
   pair: Scene; createSceneIFS

:spadfun:`createSceneIFS`\: (\ :ref:`List <l4c697374>`\  \ :ref:`List <l4c697374>`\  \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`List <l4c697374>`\  PT) -> % 
  \ ``createSceneIFS(inx, pts)``\  constructs an indexed face set node, this defines a surface represented by a set of polygons in \ ``n``\ -dimensional space.


.. index::
   pair: Scene; createSceneIFS

:spadfun:`createSceneIFS`\: \ :ref:`SceneIFS <l5363656e65494653>`\  PT -> % 
  \ ``createSceneIFS(in1)``\  constructs an indexed face set node, this defines a surface represented by a set of polygons in \ ``n``\ -dimensional space.

.. _l5363656e65-6372656174655363656e654c696e65:

.. index::
   pair: Scene; createSceneLine

:spadfun:`createSceneLine`\: (%, %, \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ) -> % 
  \ ``createSceneLine(st, en, fontScale)``\  constructs a line node, that contains a line, in \ ``n``\ -dimensions, from \ ``st``\  to \ ``en``\ . 'st' and 'en' are nodes in the scene and the line will be drawn upto their boundary. \ ``st``\  is the node at the start of the line \ ``en``\  is the node at the end of the line fontScale should be set to the full width of the diagram (not just the width of this node). If this is not known then choose an approximate value. This only affects text nodes, if \ ``st``\  or \ ``en``\ , or its subnodes, do not contain a text node then its value is not significant.


.. index::
   pair: Scene; createSceneLine

:spadfun:`createSceneLine`\: (%, %, \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`Boolean <l426f6f6c65616e>`\ ) -> % 
  \ ``createSceneLine(st, en, fontScale, shortenLine)``\  constructs a line node, that contains a line, in \ ``n``\ -dimensions, from \ ``st``\  to \ ``en``\ . 'st' and 'en' are nodes in the scene and the line will be drawn upto their boundary. \ ``st``\  is the node at the start of the line \ ``en``\  is the node at the end of the line \ ``fontScale``\  should be set to the full width of the diagram (not just the width of this node). If this is not known then choose an approximate value. This only affects text nodes, if \ ``st``\  or \ ``en``\ , or its subnodes, do not contain a text node then its value is not significant. shortenLine if \ ``true``\  line drawn upto boundary rather than centre of destination.


.. index::
   pair: Scene; createSceneLine

:spadfun:`createSceneLine`\: \ :ref:`List <l4c697374>`\  PT -> % 
  \ ``createSceneLine(line)``\  constructs a \ ``line``\  node, this contains a \ ``line``\  (represented by a list of points) in \ ``n``\ -dimensional space. The space is implicit in the \ ``PT``\  and \ ``TR``\  parameters supplied when this Scene was created.

.. _l5363656e65-6372656174655363656e654c696e6573:

.. index::
   pair: Scene; createSceneLines

:spadfun:`createSceneLines`\: \ :ref:`List <l4c697374>`\  \ :ref:`List <l4c697374>`\  PT -> % 
  \ ``createSceneLines(line)``\  constructs a \ ``line``\  node, this contains lines (represented by a list of points) in \ ``n``\ -dimensional space. The space is implicit in the \ ``PT``\  and \ ``TR``\  parameters supplied when this Scene was created.

.. _l5363656e65-6372656174655363656e654d6174657269616c:

.. index::
   pair: Scene; createSceneMaterial

:spadfun:`createSceneMaterial`\: (\ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`String <l537472696e67>`\ , \ :ref:`String <l537472696e67>`\ ) -> % 
  \ ``createSceneMaterial(lineW, lineC, fillC)``\  constructs a material node This sets the lineWidth, lineCol and fillCol for all nodes under this, unless overridden by another material node. That is the material parameters that apply to a given node are those of the closest material node above it in the hierarchy


.. index::
   pair: Scene; createSceneMaterial

:spadfun:`createSceneMaterial`\: Record(lineWidth: \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , lineCol: \ :ref:`String <l537472696e67>`\ , fillCol: \ :ref:`String <l537472696e67>`\ , matOpacity: \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ) -> % 
  \ ``createSceneMaterial(mat)``\  constructs a material node This sets the lineWidth, lineCol and fillCol for all nodes under this, unless overridden by another material node. That is the material parameters that apply to a given node are those of the closest material node above it in the hierarchy line width is expressed relative to the width of current boundary

.. _l5363656e65-6372656174655363656e654e616d6564506f696e7473:

.. index::
   pair: Scene; createSceneNamedPoints

:spadfun:`createSceneNamedPoints`\: \ :ref:`SceneNamedPoints <l5363656e654e616d6564506f696e7473>`\  PT -> % 
  \ ``createSceneNamedPoints(np)``\  constructs a named points node, this allows us to define a set of points which can be used multiple times in the scenegraph.

.. _l5363656e65-6372656174655363656e655061747465726e:

.. index::
   pair: Scene; createScenePattern

:spadfun:`createScenePattern`\: (\ :ref:`Symbol <l53796d626f6c>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`SBoundary <l53426f756e64617279>`\  PT) -> % 
  \ ``createScenePattern(ptype, step, bb)``\  creates a test pattern suitable for showing the effect of transforms. The pattern depends on \ ``ptype``\  parameter as follows: ptype="GRID"::Symbol : construct a set of horizontal and vertical lines in the current clip boundary and current material with a spacing between lines given by the \ ``step``\  parameter. ptype="SIERPINSKI"::Symbol: constructs a Sierpinski fractal. \ ``step``\  parameter gives the level of subdivision. ptype="HOUSE"::Symbol: constructs a house shape.

.. _l5363656e65-6372656174655363656e65526f6f74:

.. index::
   pair: Scene; createSceneRoot

:spadfun:`createSceneRoot`\: () -> % 
  \ ``createSceneRoot()``\  constructs the root node, all other nodes are contained in a tree structure under this node


.. index::
   pair: Scene; createSceneRoot

:spadfun:`createSceneRoot`\: (\ :ref:`Integer <l496e7465676572>`\ , \ :ref:`Integer <l496e7465676572>`\ , \ :ref:`Integer <l496e7465676572>`\ , \ :ref:`Integer <l496e7465676572>`\ ) -> % 
  \ ``createSceneRoot(minx, miny, maxx, maxy)``\  constructs the root node, all other nodes are contained in a tree structure under this node


.. index::
   pair: Scene; createSceneRoot

:spadfun:`createSceneRoot`\: \ :ref:`SBoundary <l53426f756e64617279>`\  PT -> % 
  \ ``createSceneRoot(bb)``\  constructs the root node, all other nodes are contained in a tree structure under this node

.. _l5363656e65-6372656174655363656e6552756c6572:

.. index::
   pair: Scene; createSceneRuler

:spadfun:`createSceneRuler`\: (\ :ref:`Symbol <l53796d626f6c>`\ , PT, \ :ref:`SBoundary <l53426f756e64617279>`\  PT) -> % 
  \ ``createSceneRuler(ptype, offset, bb)``\  creates a scale that can be used to provide numeric values for an axis: ptype= "HORIZONTAL"::Symbol : horizontal axis. ptype= "VERTICAL"::Symbol: vertical axis. ptype= "DEBTH"::Symbol: depth axis.

.. _l5363656e65-6372656174655363656e655368617065:

.. index::
   pair: Scene; createSceneShape

:spadfun:`createSceneShape`\: Record(shptype: \ :ref:`Symbol <l53796d626f6c>`\ , centre: PT, size: PT, fill: \ :ref:`Boolean <l426f6f6c65616e>`\ ) -> % 
  \ ``createSceneShape(shape)``\  constructs a \ ``shape``\  node, this contains a \ ``shape``\  such as a rectangle or an ellipse.


.. index::
   pair: Scene; createSceneShape

:spadfun:`createSceneShape`\: \ :ref:`SBoundary <l53426f756e64617279>`\  PT -> % 
  \ ``createSceneShape(shape)``\  constructs a \ ``shape``\  node from a boundary, this contains a \ ``shape``\  such as a rectangle or an ellipse.

.. _l5363656e65-6372656174655363656e6554657874:

.. index::
   pair: Scene; createSceneText

:spadfun:`createSceneText`\: (\ :ref:`List <l4c697374>`\  \ :ref:`String <l537472696e67>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , PT) -> % 
  \ ``createSceneText(str, sz, pz)``\  constructs a text node using information from named points node.


.. index::
   pair: Scene; createSceneText

:spadfun:`createSceneText`\: (\ :ref:`String <l537472696e67>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , PT) -> % 
  \ ``createSceneText(str, sz, pz)``\  constructs a text node, text can be used for labelling anything such as graphs, axes and so on.


.. index::
   pair: Scene; createSceneText

:spadfun:`createSceneText`\: Record(txt: \ :ref:`String <l537472696e67>`\ , siz: \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , pos: PT, np: \ :ref:`List <l4c697374>`\  \ :ref:`String <l537472696e67>`\ ) -> % 
  \ ``createSceneText(text)``\  constructs a \ ``text``\  node, \ ``text``\  can be used for labelling anything such as graphs, axes and so on.

.. _l5363656e65-6372656174655363656e655472616e73666f726d:

.. index::
   pair: Scene; createSceneTransform

:spadfun:`createSceneTransform`\: \ :ref:`STransform <l535472616e73666f726d>`\  PT -> % 
  \ ``createSceneTransform(tran)``\  constructs a transform node This transforms the points and vectors below this node If a given node has more than one transform node above it in the hierarchy then the transforms are compound

.. _l5363656e65-6372656174655363656e65557365:

.. index::
   pair: Scene; createSceneUse

:spadfun:`createSceneUse`\: \ :ref:`String <l537472696e67>`\  -> % 
  \ ``createSceneUse(nam)``\  uses another point in the scenegraph.

.. _l5363656e65-72656d6f76654368696c6421:

.. index::
   pair: Scene; removeChild!

:spadfun:`removeChild!`\: (%, %) -> \ :ref:`Void <l566f6964>`\  
  \ ``removeChild!(n, c)``\  removes the specified child node \ ``'c'``\  below node \ ``'n'``\ 

.. _l5363656e65-7365745472616e73666f726d21:

.. index::
   pair: Scene; setTransform!

:spadfun:`setTransform!`\: (%, \ :ref:`STransform <l535472616e73666f726d>`\  PT) -> \ :ref:`Void <l566f6964>`\  
  \ ``setTransform!(n, tran)``\  changes the transform without altering the scene hierarchy

.. _l5363656e65-746f4f626a:

.. index::
   pair: Scene; toObj

:spadfun:`toObj`\: (%, \ :ref:`Reference <l5265666572656e6365>`\  \ :ref:`List <l4c697374>`\  PT, \ :ref:`Reference <l5265666572656e6365>`\  \ :ref:`List <l4c697374>`\  \ :ref:`List <l4c697374>`\  \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`Reference <l5265666572656e6365>`\  \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`STransform <l535472616e73666f726d>`\  PT, \ :ref:`SBoundary <l53426f756e64617279>`\  PT) -> \ :ref:`Void <l566f6964>`\  
  \ ``toObj(n, ptLst, indexLst, indexNxt, tran, bb)``\  creates an .OBJ (Wavefront) file from scenegraph tree structure called recursively for each node, so when called on root node in scenegraph all other nodes in the scenegraph will get called. \ ``n``\  is the scene to be output to \ ``ptLst``\  and \ ``indexLst``\  \ ``ptLst``\  is the points. This will be set to ref([]) at the start and will be built up as this function is called recursively \ ``indexLst``\  is list of faces, where faces are list of points indexed by \ ``ptLst``\  This will be set to ref([]) at the start and will be built up as this function is called recursively \ ``tran``\  is the default transform which may be overridden by subnodes \ ``bb``\  is the default boundary which may be overridden by subnodes

.. _l5363656e65-746f535647:

.. index::
   pair: Scene; toSVG

:spadfun:`toSVG`\: (%, Record(lineWidth: \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , lineCol: \ :ref:`String <l537472696e67>`\ , fillCol: \ :ref:`String <l537472696e67>`\ , matOpacity: \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ), \ :ref:`STransform <l535472616e73666f726d>`\  PT, \ :ref:`SBoundary <l53426f756e64617279>`\  PT, \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , \ :ref:`Boolean <l426f6f6c65616e>`\ , \ :ref:`Boolean <l426f6f6c65616e>`\ , \ :ref:`SceneNamedPoints <l5363656e654e616d6564506f696e7473>`\  PT) -> \ :ref:`XmlElement <l586d6c456c656d656e74>`\  
  \ ``toSVG(n, mat, tran, bb, scale, clipEn, useInteger, npt)``\  creates an XmlElement containing a 'SVG' representation of node \ ``'n'``\  and the nodes below it. \ ``n``\  is the scene to be output to \ ``XML``\  elements \ ``mat``\  is the default material which may be overridden by subnodes \ ``tran``\  is the default transform which may be overridden by subnodes \ ``bb``\  is the default boundary which may be overridden by subnodes \ ``scale``\  is the \ ``scale``\  used to \ ``scale``\  into canvas, it would be better to merge this into trans. \ ``clipEn``\  if \ ``true``\  this clips the output to the boundary \ ``useInteger``\  if \ ``true``\  truncate to integer values. \ ``npt``\  names points can be provided. If not required then set to namedBranch([], [])

.. _l5363656e65-746f583344:

.. index::
   pair: Scene; toX3D

:spadfun:`toX3D`\: (%, Record(lineWidth: \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ , lineCol: \ :ref:`String <l537472696e67>`\ , fillCol: \ :ref:`String <l537472696e67>`\ , matOpacity: \ :ref:`DoubleFloat <l446f75626c65466c6f6174>`\ ), \ :ref:`STransform <l535472616e73666f726d>`\  PT, \ :ref:`SBoundary <l53426f756e64617279>`\  PT) -> \ :ref:`XmlElement <l586d6c456c656d656e74>`\  
  \ ``toX3D(n, mat, tran, bb)``\  creates an XmlElement containing a 'X3D' representation of node \ ``'n'``\  and the nodes below it. \ ``n``\  is the scene to be output to \ ``XML``\  elements \ ``mat``\  is the default material which may be overridden by subnodes \ ``tran``\  is the default transform which may be overridden by subnodes \ ``bb``\  is the default boundary which may be overridden by subnodes

.. _l5363656e65-77726974654f626a:

.. index::
   pair: Scene; writeObj

:spadfun:`writeObj`\: (%, \ :ref:`String <l537472696e67>`\ ) -> \ :ref:`Void <l566f6964>`\  
  \ ``writeObj(n, filename)``\  writes an 'OBJ' (Wavefront) representation of node \ ``'n'``\  to the filename supplied.

.. _l5363656e65-7772697465537667:

.. index::
   pair: Scene; writeSvg

:spadfun:`writeSvg`\: (%, \ :ref:`String <l537472696e67>`\ ) -> \ :ref:`Void <l566f6964>`\  
  \ ``writeSvg(n, filename)``\  writes an 'SVG' representation of node \ ``'n'``\  to the filename supplied.

.. _l5363656e65-77726974655376675175616e7469736564:

.. index::
   pair: Scene; writeSvgQuantised

:spadfun:`writeSvgQuantised`\: (%, \ :ref:`String <l537472696e67>`\ ) -> \ :ref:`Void <l566f6964>`\  
  \ ``writeSvgQuantised(n, filename)``\  writes an 'SVG' representation of node \ ``'n'``\  to the filename supplied.

.. _l5363656e65-777269746556524d4c:

.. index::
   pair: Scene; writeVRML

:spadfun:`writeVRML`\: (%, \ :ref:`String <l537472696e67>`\ ) -> \ :ref:`Void <l566f6964>`\  
  \ ``writeVRML(n, filename)``\  writes an 'VRML' representation of node \ ``'n'``\  to the filename supplied.

.. _l5363656e65-7772697465583364:

.. index::
   pair: Scene; writeX3d

:spadfun:`writeX3d`\: (%, \ :ref:`String <l537472696e67>`\ ) -> \ :ref:`Void <l566f6964>`\  
  writeX3d: (\ ``n``\ , filename) writes an 'X3D' representation of node \ ``'n'``\  to the filename supplied.


