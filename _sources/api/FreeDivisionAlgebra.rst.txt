.. index:: FreeDivisionAlgebra

.. _l467265654469766973696f6e416c6765627261:

FreeDivisionAlgebra(VAR, F)
===========================

:viewcode:`fdalg.spad line 8 <fdalg.spad#L8>` :editcode:`[edit on github] <fdalg.spad#L8>`

* VAR: \ :ref:`OrderedSet <l4f726465726564536574>`\ 

* F: \ :ref:`Field <l4669656c64>`\ 


The elements of the Free Field are represented by Admissible Linear Systems (ALS) in standard form ...


.. _l467265654469766973696f6e416c6765627261-30:

\ :ref:`0 <l4162656c69616e4d6f6e6f6964-30>`\ \: % 
  from \ :ref:`AbelianMonoid <l4162656c69616e4d6f6e6f6964>`\ 

.. _l467265654469766973696f6e416c6765627261-31:

\ :ref:`1 <l4d61676d6157697468556e6974-31>`\ \: % 
  from \ :ref:`MagmaWithUnit <l4d61676d6157697468556e6974>`\ 

.. _l467265654469766973696f6e416c6765627261-2a:

\ :ref:`\* <l4d61676d61-2a>`\ \: (%, %) -> % 
  from \ :ref:`Magma <l4d61676d61>`\ 


\ :ref:`\* <l52696768744d6f64756c65-2a>`\ \: (%, F) -> % 
  from \ :ref:`RightModule <l52696768744d6f64756c65>`\  F


\ :ref:`\* <l52696768744d6f64756c65-2a>`\ \: (%, \ :ref:`Fraction <l4672616374696f6e>`\  \ :ref:`Integer <l496e7465676572>`\ ) -> % 
  from \ :ref:`RightModule <l52696768744d6f64756c65>`\  \ :ref:`Fraction <l4672616374696f6e>`\  \ :ref:`Integer <l496e7465676572>`\ 


.. index::
   pair: FreeDivisionAlgebra; *

:spadfun:`\*`\: (%, \ :ref:`Matrix <l4d6174726978>`\  F) -> % 
  \ ``f * U``\  column transformation


\ :ref:`\* <l4c6566744d6f64756c65-2a>`\ \: (F, %) -> % 
  from \ :ref:`LeftModule <l4c6566744d6f64756c65>`\  F


\ :ref:`\* <l4c6566744d6f64756c65-2a>`\ \: (\ :ref:`Fraction <l4672616374696f6e>`\  \ :ref:`Integer <l496e7465676572>`\ , %) -> % 
  from \ :ref:`LeftModule <l4c6566744d6f64756c65>`\  \ :ref:`Fraction <l4672616374696f6e>`\  \ :ref:`Integer <l496e7465676572>`\ 


\ :ref:`\* <l4162656c69616e47726f7570-2a>`\ \: (\ :ref:`Integer <l496e7465676572>`\ , %) -> % 
  from \ :ref:`AbelianGroup <l4162656c69616e47726f7570>`\ 


.. index::
   pair: FreeDivisionAlgebra; *

:spadfun:`\*`\: (\ :ref:`Matrix <l4d6174726978>`\  F, %) -> % 
  \ ``T * f``\  row transformation


\ :ref:`\* <l4162656c69616e4d6f6e6f6964-2a>`\ \: (\ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , %) -> % 
  from \ :ref:`AbelianMonoid <l4162656c69616e4d6f6e6f6964>`\ 


\ :ref:`\* <l4162656c69616e53656d6947726f7570-2a>`\ \: (\ :ref:`PositiveInteger <l506f736974697665496e7465676572>`\ , %) -> % 
  from \ :ref:`AbelianSemiGroup <l4162656c69616e53656d6947726f7570>`\ 

.. _l467265654469766973696f6e416c6765627261-2b:

\ :ref:`+ <l4162656c69616e53656d6947726f7570-2b>`\ \: (%, %) -> % 
  from \ :ref:`AbelianSemiGroup <l4162656c69616e53656d6947726f7570>`\ 


.. index::
   pair: FreeDivisionAlgebra; +

:spadfun:`+`\: (%, F) -> % 
  \ ``f + alpha``\  adds the scalar alpha to \ ``f``\ .


.. index::
   pair: FreeDivisionAlgebra; +

:spadfun:`+`\: (F, %) -> % 
  \ ``alpha + f``\  adds the scalar alpha to \ ``f``\ .

.. _l467265654469766973696f6e416c6765627261-2d:

\ :ref:`- <l4162656c69616e47726f7570-2d>`\ \: % -> % 
  from \ :ref:`AbelianGroup <l4162656c69616e47726f7570>`\ 


\ :ref:`- <l4162656c69616e47726f7570-2d>`\ \: (%, %) -> % 
  from \ :ref:`AbelianGroup <l4162656c69616e47726f7570>`\ 


.. index::
   pair: FreeDivisionAlgebra; -

:spadfun:`-`\: (%, F) -> % 
  \ ``f - alpha``\  subtracts the scalar alpha from \ ``f``\ .


.. index::
   pair: FreeDivisionAlgebra; -

:spadfun:`-`\: (F, %) -> % 
  \ ``alpha - f``\  adds the scalar alpha to \ ``-f``\ .

.. _l467265654469766973696f6e416c6765627261-2f:

.. index::
   pair: FreeDivisionAlgebra; /

:spadfun:`/`\: (%, %) -> % 
  \ ``f / g``\  computes \ ``f``\  * \ ``g^``\ -1 for nonzero element \ ``g``\ .


.. index::
   pair: FreeDivisionAlgebra; /

:spadfun:`/`\: (%, F) -> % 
  \ ``f / alpha``\  computes \ ``f``\  / alpha for nonzero alpha.


.. index::
   pair: FreeDivisionAlgebra; /

:spadfun:`/`\: (F, %) -> % 
  \ ``alpha / f``\  computes alpha / \ ``f``\  for nonzero \ ``f``\ .

.. _l467265654469766973696f6e416c6765627261-3d:

\ :ref:`= <l426173696354797065-3d>`\ \: (%, %) -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  from \ :ref:`BasicType <l426173696354797065>`\ 

.. _l467265654469766973696f6e416c6765627261-5e:

.. index::
   pair: FreeDivisionAlgebra; ^

:spadfun:`^`\: (%, \ :ref:`Integer <l496e7465676572>`\ ) -> % 
  \ ``f^n``\  returns \ ``f^n``\ .


\ :ref:`^ <l4d61676d6157697468556e6974-5e>`\ \: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  from \ :ref:`MagmaWithUnit <l4d61676d6157697468556e6974>`\ 


.. index::
   pair: FreeDivisionAlgebra; ^

:spadfun:`^`\: (%, \ :ref:`PositiveInteger <l506f736974697665496e7465676572>`\ ) -> % 
  \ ``f^n``\  returns \ ``f^n``\ .

.. _l467265654469766973696f6e416c6765627261-7e3d:

\ :ref:`~= <l426173696354797065-7e3d>`\ \: (%, %) -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  from \ :ref:`BasicType <l426173696354797065>`\ 

.. _l467265654469766973696f6e416c6765627261-616464414c53:

.. index::
   pair: FreeDivisionAlgebra; addALS

:spadfun:`addALS`\: (%, %) -> % 
  \ ``addALS(f,g)``\  computes \ ``f+g``\  in terms of the admissible linear systems for \ ``f``\  and \ ``g``\  (without minimization).

.. _l467265654469766973696f6e416c6765627261-616464436f6c756d6e7321:

.. index::
   pair: FreeDivisionAlgebra; addColumns!

:spadfun:`addColumns!`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , F) -> % 
  \ ``addColumns!(f, i, j, alpha)``\  adds alpha*column(\ ``i``\ ) to column(\ ``j``\ ) in A and subtracts row(\ ``j``\ ) from row(\ ``i``\ ) in \ ``s``\  (in the ALS of \ ``f``\ ), i.e. (A*U)(U^-1*s) = \ ``v``\ .

.. _l467265654469766973696f6e416c6765627261-616464436f6c756d6e73526f777321:

.. index::
   pair: FreeDivisionAlgebra; addColumnsRows!

:spadfun:`addColumnsRows!`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , F) -> % 
  \ ``addColumnsRows!(f, i, j, alpha)``\  adds alpha*column(\ ``i``\ ) to column(\ ``j``\ ) and subtracts alpha*row(\ ``j``\ ) from row(\ ``i``\ ) in the ALS of \ ``f``\ .

.. _l467265654469766973696f6e416c6765627261-6164644d494e:

.. index::
   pair: FreeDivisionAlgebra; addMIN

:spadfun:`addMIN`\: (%, %) -> % 
  \ ``addMIN(f,g)``\  uses addALS(\ ``f``\ ,\ ``g``\ ) with minimization.

.. _l467265654469766973696f6e416c6765627261-616464526f777321:

.. index::
   pair: FreeDivisionAlgebra; addRows!

:spadfun:`addRows!`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , F) -> % 
  \ ``addRows!(f, i, j, alpha)``\  adds alpha*row(\ ``i``\ ) to row(\ ``j``\ ) in the ALS of \ ``f``\ .

.. _l467265654469766973696f6e416c6765627261-616464526f7773436f6c756d6e7321:

.. index::
   pair: FreeDivisionAlgebra; addRowsColumns!

:spadfun:`addRowsColumns!`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , F) -> % 
  \ ``addRowsColumns!(f, i, j, alpha)``\  adds alpha*row(\ ``i``\ ) to row(\ ``j``\ ) and subtracts alpha*column(\ ``j``\ ) from column(\ ``i``\ ) in the ALS of \ ``f``\ .

.. _l467265654469766973696f6e416c6765627261-61646d69737369626c654c696e65617253797374656d:

.. index::
   pair: FreeDivisionAlgebra; admissibleLinearSystem

:spadfun:`admissibleLinearSystem`\: % -> \ :ref:`OutputForm <l4f7574707574466f726d>`\  
  \ ``admissibleLinearSystem(f)``\  output as ALS.

.. _l467265654469766973696f6e416c6765627261-616e6e6968696c6174653f:

\ :ref:`annihilate? <l526e67-616e6e6968696c6174653f>`\ \: (%, %) -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  from \ :ref:`Rng <l526e67>`\ 

.. _l467265654469766973696f6e416c6765627261-616e7469436f6d6d757461746f72:

\ :ref:`antiCommutator <l4e6f6e4173736f6369617469766553656d69526e67-616e7469436f6d6d757461746f72>`\ \: (%, %) -> % 
  from \ :ref:`NonAssociativeSemiRng <l4e6f6e4173736f6369617469766553656d69526e67>`\ 

.. _l467265654469766973696f6e416c6765627261-617070656e64537570706f727421:

.. index::
   pair: FreeDivisionAlgebra; appendSupport!

:spadfun:`appendSupport!`\: (%, \ :ref:`List <l4c697374>`\  \ :ref:`FreeMonoid <l467265654d6f6e6f6964>`\  VAR) -> % 
  \ ``appendSupport! (f, lst)``\  appends variables not in the support.

.. _l467265654469766973696f6e416c6765627261-6173736f6369617465733f:

\ :ref:`associates? <l456e7469726552696e67-6173736f6369617465733f>`\ \: (%, %) -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  from \ :ref:`EntireRing <l456e7469726552696e67>`\ 

.. _l467265654469766973696f6e416c6765627261-6173736f636961746f72:

\ :ref:`associator <l4e6f6e4173736f63696174697665526e67-6173736f636961746f72>`\ \: (%, %, %) -> % 
  from \ :ref:`NonAssociativeRng <l4e6f6e4173736f63696174697665526e67>`\ 

.. _l467265654469766973696f6e416c6765627261-626c6f636b456c696d696e6174696f6e:

.. index::
   pair: FreeDivisionAlgebra; blockElimination

:spadfun:`blockElimination`\: (%, \ :ref:`List <l4c697374>`\  \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`List <l4c697374>`\  \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`Boolean <l426f6f6c65616e>`\ , \ :ref:`List <l4c697374>`\  \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`List <l4c697374>`\  \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`Boolean <l426f6f6c65616e>`\ ) -> \ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  F 
  \ ``blockElimination(f, rsrc, rdst, flg_u, csrc, cdst, flg_v)``\  returns transformation matrices if it is possible to eliminate all entries in \ ``rdst``\  \ ``x``\  \ ``cdst``\  (including columns in \ ``u``\  if \ ``flg_u``\  = \ ``true``\ , including rows in \ ``v``\  if flg_v = \ ``true``\ ) by using rows in \ ``rsrc``\  and columns in \ ``csrc``\ . Otherwise an empty list.


.. index::
   pair: FreeDivisionAlgebra; blockElimination

:spadfun:`blockElimination`\: (%, \ :ref:`List <l4c697374>`\  \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`List <l4c697374>`\  \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`List <l4c697374>`\  \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`List <l4c697374>`\  \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> \ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  F 
  \ ``blockElimination(f, rsrc, rdst, csrc, cdst)``\  flg_u = \ ``true``\ , flg_v = \ ``true``\ 

.. _l467265654469766973696f6e416c6765627261-626c6f636b537472756374757265:

.. index::
   pair: FreeDivisionAlgebra; blockStructure

:spadfun:`blockStructure`\: % -> \ :ref:`Matrix <l4d6174726978>`\  \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\  
  \ ``blockStructure(f)``\  analyzes the structure of the ALS of \ ``f``\  and detects blocks with respect to an upper triangular structure. Entry (\ ``i``\ ,1) contains the first row, (\ ``i``\ ,2) the last row, (\ ``i``\ ,3) the size and (\ ``i``\ ,4) if block \ ``i``\  is refined.

.. _l467265654469766973696f6e416c6765627261-6368617261637465726973746963:

\ :ref:`characteristic <l4e6f6e4173736f6369617469766552696e67-6368617261637465726973746963>`\ \: () -> \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\  
  from \ :ref:`NonAssociativeRing <l4e6f6e4173736f6369617469766552696e67>`\ 

.. _l467265654469766973696f6e416c6765627261-636f65726365:

.. index::
   pair: FreeDivisionAlgebra; coerce

:spadfun:`coerce`\: % -> \ :ref:`OutputForm <l4f7574707574466f726d>`\  
  \ ``coerce(f)``\  prints the ALS of \ ``f``\  if the debug flag is set and a rational expression if the alternative output flag is set.


.. index::
   pair: FreeDivisionAlgebra; coerce

:spadfun:`coerce`\: % -> \ :ref:`XDistributedPolynomial <l584469737472696275746564506f6c796e6f6d69616c>`\ (VAR, F) 
  \ ``coerce(f)``\  converts the element to XDPOLY (if possible).


.. index::
   pair: FreeDivisionAlgebra; coerce

:spadfun:`coerce`\: F -> % 
  \ ``coerce(c)``\  converts the constant \ ``c``\  into an element of the free field represented by an ALS in minimal refined form.


\ :ref:`coerce <l416c6765627261-636f65726365>`\ \: \ :ref:`Fraction <l4672616374696f6e>`\  \ :ref:`Integer <l496e7465676572>`\  -> % 
  from \ :ref:`Algebra <l416c6765627261>`\  \ :ref:`Fraction <l4672616374696f6e>`\  \ :ref:`Integer <l496e7465676572>`\ 


.. index::
   pair: FreeDivisionAlgebra; coerce

:spadfun:`coerce`\: \ :ref:`FreeMonoid <l467265654d6f6e6f6964>`\  VAR -> % 
  \ ``coerce(m)``\  converts the monoid \ ``m``\  into an element of the free field represented by an ALS in minimal refined form.


\ :ref:`coerce <l4e6f6e4173736f6369617469766552696e67-636f65726365>`\ \: \ :ref:`Integer <l496e7465676572>`\  -> % 
  from \ :ref:`NonAssociativeRing <l4e6f6e4173736f6369617469766552696e67>`\ 


.. index::
   pair: FreeDivisionAlgebra; coerce

:spadfun:`coerce`\: \ :ref:`XDistributedPolynomial <l584469737472696275746564506f6c796e6f6d69616c>`\ (VAR, F) -> % 
  \ ``coerce(p)``\  converts the polynomial \ ``p``\  to an element in the free field represented by an minimal admissible linear system.

.. _l467265654469766973696f6e416c6765627261-636f6c756d6e5370616e:

.. index::
   pair: FreeDivisionAlgebra; columnSpan

:spadfun:`columnSpan`\: % -> \ :ref:`Stream <l53747265616d>`\  \ :ref:`Matrix <l4d6174726978>`\  \ :ref:`XDistributedPolynomial <l584469737472696275746564506f6c796e6f6d69616c>`\ (VAR, F) 
  \ ``columnSpan(f)``\  computes the column span for a regular element, that is (\ ``v'``\ , \ ``Mv'``\ , M^2v', ...) where PAs=Pv=v' with PA = \ ``I``\ -\ ``M``\ .

.. _l467265654469766973696f6e416c6765627261-636f6d6d757461746f72:

\ :ref:`commutator <l4e6f6e4173736f63696174697665526e67-636f6d6d757461746f72>`\ \: (%, %) -> % 
  from \ :ref:`NonAssociativeRng <l4e6f6e4173736f63696174697665526e67>`\ 

.. _l467265654469766973696f6e416c6765627261-636f7079:

.. index::
   pair: FreeDivisionAlgebra; copy

:spadfun:`copy`\: % -> % 
  \ ``copy(f)``\  gives a copy of the element \ ``f``\ .


.. index::
   pair: FreeDivisionAlgebra; copy

:spadfun:`copy`\: (%, F) -> % 
  \ ``copy(f, alpha)``\  gives a copy of element \ ``f``\  multiplied by alpha.

.. _l467265654469766973696f6e416c6765627261-64696d656e73696f6e:

.. index::
   pair: FreeDivisionAlgebra; dimension

:spadfun:`dimension`\: % -> \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\  
  \ ``dimension(f)``\  returns the dimension of the ALS.

.. _l467265654469766973696f6e416c6765627261-64697361626c65416c7465726e61746976654f7574707574:

.. index::
   pair: FreeDivisionAlgebra; disableAlternativeOutput

:spadfun:`disableAlternativeOutput`\: % -> % 
  \ ``disableAlternativeOutput(f)``\  disable output as rational expression.

.. _l467265654469766973696f6e416c6765627261-64697361626c6544656275674f7574707574:

.. index::
   pair: FreeDivisionAlgebra; disableDebugOutput

:spadfun:`disableDebugOutput`\: % -> % 
  \ ``disableDebugOutput(f)``\  disable displaying the ALS.

.. _l467265654469766973696f6e416c6765627261-646973706c6179:

.. index::
   pair: FreeDivisionAlgebra; display

:spadfun:`display`\: (%, \ :ref:`List <l4c697374>`\  \ :ref:`Symbol <l53796d626f6c>`\ ) -> \ :ref:`OutputForm <l4f7574707574466f726d>`\  
  \ ``display(f,[s])``\  prints the element \ ``f``\  as A*(\ ``s_1``\ ,\ ``s_2``\ ,...,\ ``s_n``\ )' = \ ``v``\ .


.. index::
   pair: FreeDivisionAlgebra; display

:spadfun:`display`\: (%, \ :ref:`OutputForm <l4f7574707574466f726d>`\ ) -> \ :ref:`OutputForm <l4f7574707574466f726d>`\  
  \ ``display(f,sol)``\  prints the element \ ``f``\  as A*sol = \ ``v``\ .

.. _l467265654469766973696f6e416c6765627261-656c74:

.. index::
   pair: FreeDivisionAlgebra; elt

:spadfun:`elt`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> F 
  \ ``elt(f, i)``\  returns \ ``v``\ (\ ``i``\ ) from the ALS of \ ``f``\ .


.. index::
   pair: FreeDivisionAlgebra; elt

:spadfun:`elt`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> \ :ref:`XDistributedPolynomial <l584469737472696275746564506f6c796e6f6d69616c>`\ (VAR, F) 
  \ ``elt(f, i, j)``\  returns A(\ ``i``\ ,\ ``j``\ ) from the ALS of \ ``f``\ .

.. _l467265654469766973696f6e416c6765627261-656e61626c65416c7465726e61746976654f7574707574:

.. index::
   pair: FreeDivisionAlgebra; enableAlternativeOutput

:spadfun:`enableAlternativeOutput`\: % -> % 
  \ ``enableAlternativeOutput(f)``\  enable output as rational expression.

.. _l467265654469766973696f6e416c6765627261-656e61626c6544656275674f7574707574:

.. index::
   pair: FreeDivisionAlgebra; enableDebugOutput

:spadfun:`enableDebugOutput`\: % -> % 
  \ ``enableDebugOutput(f)``\  enable displaying the ALS.

.. _l467265654469766973696f6e416c6765627261-657871756f:

\ :ref:`exquo <l456e7469726552696e67-657871756f>`\ \: (%, %) -> Union(%, failed) 
  from \ :ref:`EntireRing <l456e7469726552696e67>`\ 

.. _l467265654469766973696f6e416c6765627261-657874656e646564414c53:

.. index::
   pair: FreeDivisionAlgebra; extendedALS

:spadfun:`extendedALS`\: % -> % 
  \ ``extendedALS(f)``\  returns an extended ALS for \ ``f``\ , that is, 1*f (with a scalar first row).

.. _l467265654469766973696f6e416c6765627261-666163746f72:

.. index::
   pair: FreeDivisionAlgebra; factor

:spadfun:`factor`\: % -> \ :ref:`List <l4c697374>`\  % 
  \ ``factor(f)``\  factorizes \ ``f``\  in f=f_1*f_2*...*f_k with atoms (irreducible elements) f_i. Notice that this factorization is unique only with respect to similarity.

.. _l467265654469766973696f6e416c6765627261-666163746f72697a6174696f6e4571756174696f6e73:

.. index::
   pair: FreeDivisionAlgebra; factorizationEquations

:spadfun:`factorizationEquations`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> \ :ref:`List <l4c697374>`\  \ :ref:`Polynomial <l506f6c796e6f6d69616c>`\  F 
  \ ``factorizationEquations(f,k_rows,k_cols)``\  for debugging purposes (interface LINPEN)

.. _l467265654469766973696f6e416c6765627261-666163746f72697a6174696f6e47726f65626e6572:

.. index::
   pair: FreeDivisionAlgebra; factorizationGroebner

:spadfun:`factorizationGroebner`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> \ :ref:`List <l4c697374>`\  \ :ref:`Polynomial <l506f6c796e6f6d69616c>`\  F 
  \ ``factorizationGroebner(f,k_rows,k_cols)``\  for debugging purposes (interface LINPEN)

.. _l467265654469766973696f6e416c6765627261-666163746f72697a6174696f6e536f6c7665:

.. index::
   pair: FreeDivisionAlgebra; factorizationSolve

:spadfun:`factorizationSolve`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> \ :ref:`List <l4c697374>`\  \ :ref:`List <l4c697374>`\  \ :ref:`Equation <l4571756174696f6e>`\  \ :ref:`Polynomial <l506f6c796e6f6d69616c>`\  F 
  \ ``factorizationSolve(f,k_rows,k_cols)``\  returns a (possible empty) list of solutions for an admissible transformation to create an upper right block of zeros of size \ ``k_rows``\  times \ ``k_cols``\ .

.. _l467265654469766973696f6e416c6765627261-666163746f72697a6174696f6e5472616e73666f726d6174696f6e73:

.. index::
   pair: FreeDivisionAlgebra; factorizationTransformations

:spadfun:`factorizationTransformations`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`List <l4c697374>`\  \ :ref:`Equation <l4571756174696f6e>`\  \ :ref:`Polynomial <l506f6c796e6f6d69616c>`\  F) -> \ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  F 
  \ ``factorizationTransformations(f,k_rows,k_cols,sol)``\  for debugging purposes (interface LINPEN)

.. _l467265654469766973696f6e416c6765627261-666163746f72697a65:

.. index::
   pair: FreeDivisionAlgebra; factorize

:spadfun:`factorize`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> \ :ref:`List <l4c697374>`\  % 
  \ ``factorize(f,k)``\  factorizes \ ``f``\  in f=g*h with rank(\ ``g``\ )\ ``=k``\  if possible (if necessary by using non-linear techniques).

.. _l467265654469766973696f6e416c6765627261-666163746f7273:

.. index::
   pair: FreeDivisionAlgebra; factors

:spadfun:`factors`\: % -> \ :ref:`List <l4c697374>`\  % 
  \ ``factors(f)``\  analysis the block structure of the system matrix of the ALS of \ ``f``\  to split \ ``f``\  into factors.

.. _l467265654469766973696f6e416c6765627261-696e73657274526f7773436f6c756d6e73:

.. index::
   pair: FreeDivisionAlgebra; insertRowsColumns

:spadfun:`insertRowsColumns`\: (%, \ :ref:`List <l4c697374>`\  \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`List <l4c697374>`\  \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``insertRowsColumns(f, lst_row, lst_col)``\  returns a new system with rows and columns inserted. An index \ ``k``\  means a new row/column between \ ``k``\  and \ ``k+1``\ . The number of rows and columns have to be the same!

.. _l467265654469766973696f6e416c6765627261-696e74657276616c:

.. index::
   pair: FreeDivisionAlgebra; interval

:spadfun:`interval`\: (\ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> \ :ref:`List <l4c697374>`\  \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\  
  \ ``interval(i, j)``\  creates list [\ ``i``\ , \ ``i+1``\ , ..., \ ``j``\ ]

.. _l467265654469766973696f6e416c6765627261-696e76:

\ :ref:`inv <l4469766973696f6e52696e67-696e76>`\ \: % -> % 
  from \ :ref:`DivisionRing <l4469766973696f6e52696e67>`\ 

.. _l467265654469766973696f6e416c6765627261-696e7665727365:

.. index::
   pair: FreeDivisionAlgebra; inverse

:spadfun:`inverse`\: % -> % 
  \ ``inverse(f)``\  \ ``f^``\ -1 using invertMIN.

.. _l467265654469766973696f6e416c6765627261-696e76657274414c53:

.. index::
   pair: FreeDivisionAlgebra; invertALS

:spadfun:`invertALS`\: % -> % 
  \ ``invertALS(f)``\  computes \ ``f^``\ -1 in terms of the ALS for \ ``f``\ . There is no check if \ ``f``\  is invertible!

.. _l467265654469766973696f6e416c6765627261-696e766572744d494e:

.. index::
   pair: FreeDivisionAlgebra; invertMIN

:spadfun:`invertMIN`\: % -> % 
  \ ``invertMIN(f)``\  uses invertSTD(\ ``f``\ ) and minimization to construct a minimal system for \ ``f^``\ -1. Linear techniques are used to get a fine pivot block structure.

.. _l467265654469766973696f6e416c6765627261-696e76657274535444:

.. index::
   pair: FreeDivisionAlgebra; invertSTD

:spadfun:`invertSTD`\: % -> % 
  \ ``invertSTD(f)``\  computes the standard inverse of \ ``f``\  in terems of the admissible linear system There is no check if \ ``f``\  is invertible!

.. _l467265654469766973696f6e416c6765627261-6c61746578:

\ :ref:`latex <l53657443617465676f7279-6c61746578>`\ \: % -> \ :ref:`String <l537472696e67>`\  
  from \ :ref:`SetCategory <l53657443617465676f7279>`\ 

.. _l467265654469766973696f6e416c6765627261-6c656674466163746f72:

.. index::
   pair: FreeDivisionAlgebra; leftFactor

:spadfun:`leftFactor`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``leftFactor(f,k)``\  returns the left factor of rank \ ``k``\  of a polynomial \ ``f``\  or 1 if it\ ``'s``\  not possible by linear techniques.

.. _l467265654469766973696f6e416c6765627261-6c65667446616d696c79:

.. index::
   pair: FreeDivisionAlgebra; leftFamily

:spadfun:`leftFamily`\: % -> \ :ref:`List <l4c697374>`\  \ :ref:`OutputForm <l4f7574707574466f726d>`\  
  \ ``leftFamily(f)``\  prints the left family s=A^-1*v.

.. _l467265654469766973696f6e416c6765627261-6c6566744d696e696d697a6174696f6e:

.. index::
   pair: FreeDivisionAlgebra; leftMinimization

:spadfun:`leftMinimization`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``leftMinimization(f, i_min, i_max)``\  tries to apply a left minimization step with respect to the pivot block with the rows/columns (\ ``i_min``\ , ..., i_max).

.. _l467265654469766973696f6e416c6765627261-6c656674506f776572:

\ :ref:`leftPower <l4d61676d6157697468556e6974-6c656674506f776572>`\ \: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  from \ :ref:`MagmaWithUnit <l4d61676d6157697468556e6974>`\ 


\ :ref:`leftPower <l4d61676d61-6c656674506f776572>`\ \: (%, \ :ref:`PositiveInteger <l506f736974697665496e7465676572>`\ ) -> % 
  from \ :ref:`Magma <l4d61676d61>`\ 

.. _l467265654469766973696f6e416c6765627261-6c6566745265636970:

\ :ref:`leftRecip <l4d61676d6157697468556e6974-6c6566745265636970>`\ \: % -> Union(%, failed) 
  from \ :ref:`MagmaWithUnit <l4d61676d6157697468556e6974>`\ 

.. _l467265654469766973696f6e416c6765627261-6c696e656172697a6174696f6e:

.. index::
   pair: FreeDivisionAlgebra; linearization

:spadfun:`linearization`\: % -> \ :ref:`Matrix <l4d6174726978>`\  % 
  \ ``linearization(f)``\  returns the element \ ``f``\  as linearization with entries represented by admissible linear systems in minimal refined form.


.. index::
   pair: FreeDivisionAlgebra; linearization

:spadfun:`linearization`\: % -> \ :ref:`Matrix <l4d6174726978>`\  \ :ref:`XDistributedPolynomial <l584469737472696275746564506f6c796e6f6d69616c>`\ (VAR, F) 
  \ ``linearization(f)``\  returns the element \ ``f``\  as linearization.

.. _l467265654469766973696f6e416c6765627261-6d6174726978:

.. index::
   pair: FreeDivisionAlgebra; matrix

:spadfun:`matrix`\: % -> \ :ref:`Matrix <l4d6174726978>`\  \ :ref:`XDistributedPolynomial <l584469737472696275746564506f6c796e6f6d69616c>`\ (VAR, F) 
  \ ``matrix(f)``\  returns the matrix of the ALS of \ ``f``\ .


.. index::
   pair: FreeDivisionAlgebra; matrix

:spadfun:`matrix`\: (%, \ :ref:`FreeMonoid <l467265654d6f6e6f6964>`\  VAR) -> \ :ref:`Matrix <l4d6174726978>`\  F 
  \ ``matrix(f,m)``\  returns the coefficient matrix for the monomial \ ``m``\  of the ALS of \ ``f``\ .

.. _l467265654469766973696f6e416c6765627261-6d696e696d616c3f:

.. index::
   pair: FreeDivisionAlgebra; minimal?

:spadfun:`minimal?`\: % -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  \ ``minimal?(f)``\  is \ ``f``\  represented by a minimal ALS?

.. _l467265654469766973696f6e416c6765627261-6d696e696d697a65:

.. index::
   pair: FreeDivisionAlgebra; minimize

:spadfun:`minimize`\: % -> % 
  \ ``minimize(f)``\  minimizes the underlying ALS by applying left and right block minimization steps. Minimality is only guaranteed if the remaining blocks are refined.

.. _l467265654469766973696f6e416c6765627261-6d756c7469706c79414c53:

.. index::
   pair: FreeDivisionAlgebra; multiplyALS

:spadfun:`multiplyALS`\: (%, %) -> % 
  \ ``multiplyALS(f,g)``\  computes \ ``f*g``\  in terms of the admissible linear systems for \ ``f``\  and \ ``g``\  (without minimization).

.. _l467265654469766973696f6e416c6765627261-6d756c7469706c79436f6c756d6e21:

.. index::
   pair: FreeDivisionAlgebra; multiplyColumn!

:spadfun:`multiplyColumn!`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , F) -> % 
  \ ``multiplyColumn!(f, i, alpha)``\  multiplies column(\ ``i``\ ) by alpha in the ALS of \ ``f``\ .

.. _l467265654469766973696f6e416c6765627261-6d756c7469706c794d494e:

.. index::
   pair: FreeDivisionAlgebra; multiplyMIN

:spadfun:`multiplyMIN`\: (%, %) -> % 
  \ ``multiplyMIN(f,g)``\  uses multiplyALS(\ ``f``\ ,\ ``g``\ ) with minimization.

.. _l467265654469766973696f6e416c6765627261-6d756c7469706c79526f7721:

.. index::
   pair: FreeDivisionAlgebra; multiplyRow!

:spadfun:`multiplyRow!`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , F) -> % 
  \ ``multiplyRow!(f, i, alpha)``\  multiplies row(\ ``i``\ ) by alpha in the ALS of \ ``f``\ .

.. _l467265654469766973696f6e416c6765627261-6d757461626c653f:

.. index::
   pair: FreeDivisionAlgebra; mutable?

:spadfun:`mutable?`\: % -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  \ ``mutable?(f)``\  is the underlying ALS of \ ``f``\  mutable?

.. _l467265654469766973696f6e416c6765627261-6e6577:

.. index::
   pair: FreeDivisionAlgebra; new

:spadfun:`new`\: (\ :ref:`FreeMonoid <l467265654d6f6e6f6964>`\  VAR, F) -> % 
  \ ``new(m,c)``\  creates a monomial element with coefficient \ ``c``\ .


.. index::
   pair: FreeDivisionAlgebra; new

:spadfun:`new`\: (\ :ref:`LinearMultivariateMatrixPencil <l4c696e6561724d756c7469766172696174654d617472697850656e63696c>`\  F, \ :ref:`List <l4c697374>`\  \ :ref:`FreeMonoid <l467265654d6f6e6f6964>`\  VAR) -> % 
  \ ``new(lp, lst)``\  creates an element by the linear multivariate matrix pencil \ ``lp``\  and the list of monomials \ ``lst``\ .


.. index::
   pair: FreeDivisionAlgebra; new

:spadfun:`new`\: F -> % 
  \ ``new(c)``\  creates a constant element.

.. _l467265654469766973696f6e416c6765627261-6e6f726d616c414c53:

.. index::
   pair: FreeDivisionAlgebra; normalALS

:spadfun:`normalALS`\: % -> % 
  \ ``normalALS(f)``\  removes a scalar first row of an (extended) ALS.

.. _l467265654469766973696f6e416c6765627261-6e6f726d616c697a6521:

.. index::
   pair: FreeDivisionAlgebra; normalize!

:spadfun:`normalize!`\: % -> % 
  \ ``normalize!(f)``\  rescales the rows such that the first nonzero entry of the coefficient matrix in the diagonal is one. The right hand side is normalized by normalizeRHS! and the non-zero entry is in the last row of the corresponding block.

.. _l467265654469766973696f6e416c6765627261-6e6f726d616c697a654449414721:

.. index::
   pair: FreeDivisionAlgebra; normalizeDIAG!

:spadfun:`normalizeDIAG!`\: % -> % 
  \ ``normalizeDIAG!(f)``\  rescales the rows such that the first nonzero entry of the coefficient matrix in the diagonal is one.

.. _l467265654469766973696f6e416c6765627261-6e6f726d616c697a65504c5321:

.. index::
   pair: FreeDivisionAlgebra; normalizePLS!

:spadfun:`normalizePLS!`\: % -> % 
  \ ``normalizePLS!(f)``\  scales and rearranges rows and columns of the system matrix such that the constant part of the system matrix is the identity matrix (possibly of smaller size).

.. _l467265654469766973696f6e416c6765627261-6e6f726d616c697a6552485321:

.. index::
   pair: FreeDivisionAlgebra; normalizeRHS!

:spadfun:`normalizeRHS!`\: % -> % 
  \ ``normalizeRHS!(f)``\  eliminates non-zero entries in the right hand side of ALS with respect of the non-zero entry with the highest index.

.. _l467265654469766973696f6e416c6765627261-6f6e653f:

\ :ref:`one? <l4d61676d6157697468556e6974-6f6e653f>`\ \: % -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  from \ :ref:`MagmaWithUnit <l4d61676d6157697468556e6974>`\ 

.. _l467265654469766973696f6e416c6765627261-6f70706f736974653f:

\ :ref:`opposite? <l4162656c69616e4d6f6e6f6964-6f70706f736974653f>`\ \: (%, %) -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  from \ :ref:`AbelianMonoid <l4162656c69616e4d6f6e6f6964>`\ 

.. _l467265654469766973696f6e416c6765627261-70656e63696c:

.. index::
   pair: FreeDivisionAlgebra; pencil

:spadfun:`pencil`\: % -> \ :ref:`LinearMultivariateMatrixPencil <l4c696e6561724d756c7469766172696174654d617472697850656e63696c>`\  F 
  \ ``pencil(f)``\  returns a pointer to the underlying pencil.

.. _l467265654469766973696f6e416c6765627261-706c656e617279506f776572:

\ :ref:`plenaryPower <l4e6f6e4173736f63696174697665416c6765627261-706c656e617279506f776572>`\ \: (%, \ :ref:`PositiveInteger <l506f736974697665496e7465676572>`\ ) -> % 
  from \ :ref:`NonAssociativeAlgebra <l4e6f6e4173736f63696174697665416c6765627261>`\  \ :ref:`Fraction <l4672616374696f6e>`\  \ :ref:`Integer <l496e7465676572>`\ 

.. _l467265654469766973696f6e416c6765627261-706f6c796e6f6d69616c3f:

.. index::
   pair: FreeDivisionAlgebra; polynomial?

:spadfun:`polynomial?`\: % -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  \ ``polynomial?(f)``\  is the ALS in polynomial form?

.. _l467265654469766973696f6e416c6765627261-706f6c796e6f6d69616c:

.. index::
   pair: FreeDivisionAlgebra; polynomial

:spadfun:`polynomial`\: % -> \ :ref:`XDistributedPolynomial <l584469737472696275746564506f6c796e6f6d69616c>`\ (VAR, F) 
  \ ``polynomial(f)``\  returns \ ``f``\  as XDPOLY (if possible)

.. _l467265654469766973696f6e416c6765627261-71616464436f6c756d6e7321:

.. index::
   pair: FreeDivisionAlgebra; qaddColumns!

:spadfun:`qaddColumns!`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , F) -> % 
  \ ``addColumns!(f, i, j, alpha)``\  adds alpha*column(\ ``i``\ ) to column(\ ``j``\ ) in A and subtracts row(\ ``j``\ ) from row(\ ``i``\ ) in \ ``s``\  (in the ALS of \ ``f``\ ), i.e. (A*U)(U^-1*s) = \ ``v``\ .

.. _l467265654469766973696f6e416c6765627261-71616464526f777321:

.. index::
   pair: FreeDivisionAlgebra; qaddRows!

:spadfun:`qaddRows!`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , F) -> % 
  \ ``addRows!(f, i, j, alpha)``\  adds alpha*row(\ ``i``\ ) to row(\ ``j``\ ) in the ALS of \ ``f``\ .

.. _l467265654469766973696f6e416c6765627261-71656c74:

.. index::
   pair: FreeDivisionAlgebra; qelt

:spadfun:`qelt`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> \ :ref:`XDistributedPolynomial <l584469737472696275746564506f6c796e6f6d69616c>`\ (VAR, F) 
  \ ``qelt(f, i, j)``\  returns A(\ ``i``\ ,\ ``j``\ ) from the ALS of \ ``f``\ .

.. _l467265654469766973696f6e416c6765627261-716e6577:

.. index::
   pair: FreeDivisionAlgebra; qnew

:spadfun:`qnew`\: (\ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`List <l4c697374>`\  \ :ref:`FreeMonoid <l467265654d6f6e6f6964>`\  VAR) -> % 
  \ ``qnew(n, lst)``\  creates an empty ALS of dimension \ ``n``\ .


.. index::
   pair: FreeDivisionAlgebra; qnew

:spadfun:`qnew`\: \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\  -> % 
  \ ``qnew(n)``\  creates an empty ALS of dimension \ ``n``\ .

.. _l467265654469766973696f6e416c6765627261-71726567756c61723f:

.. index::
   pair: FreeDivisionAlgebra; qregular?

:spadfun:`qregular?`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  \ ``qregular?(f, i_min, i_max)``\  does the specified diagonal block define a regular element?

.. _l467265654469766973696f6e416c6765627261-7173776170436f6c756d6e7321:

.. index::
   pair: FreeDivisionAlgebra; qswapColumns!

:spadfun:`qswapColumns!`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``swapColumns!(f, i, j)``\  exchanges columns \ ``i``\  and \ ``j``\  in the ALS of \ ``f``\ .

.. _l467265654469766973696f6e416c6765627261-7173776170526f777321:

.. index::
   pair: FreeDivisionAlgebra; qswapRows!

:spadfun:`qswapRows!`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``swapRows!(f, i, j)``\  exchanges rows \ ``i``\  and \ ``j``\  in the ALS of \ ``f``\ .

.. _l467265654469766973696f6e416c6765627261-717a65726f3f:

.. index::
   pair: FreeDivisionAlgebra; qzero?

:spadfun:`qzero?`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  \ ``qzero?(f, i_min, i_max, j_min, j_max)``\  is the specified block zero (in the system matrix)?


.. index::
   pair: FreeDivisionAlgebra; qzero?

:spadfun:`qzero?`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`FreeMonoid <l467265654d6f6e6f6964>`\  VAR) -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  \ ``qzero?(f, i_min, i_max, j_min, j_max, m)``\  is the specified block zero in the (system) matrix corresponding to the monomial \ ``m?``\ 


.. index::
   pair: FreeDivisionAlgebra; qzero?

:spadfun:`qzero?`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  \ ``qzero?(f, i_min, i_max, j_min, j_max, l)``\  is the specified block zero in matrix \ ``l?``\ 

.. _l467265654469766973696f6e416c6765627261-72616e6b:

.. index::
   pair: FreeDivisionAlgebra; rank

:spadfun:`rank`\: % -> \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\  
  \ ``rank(f)``\  returns the rank of the element \ ``f``\ , that is, the dimension of a minimal admissible linear system (for \ ``f``\ ).

.. _l467265654469766973696f6e416c6765627261-72617465787072:

.. index::
   pair: FreeDivisionAlgebra; ratexpr

:spadfun:`ratexpr`\: % -> \ :ref:`OutputForm <l4f7574707574466f726d>`\  
  \ ``ratexpr(f)``\  analysis the block structure of the admissible linear system to write \ ``f``\  as rational expression.

.. _l467265654469766973696f6e416c6765627261-72617465787072496e7665727365:

.. index::
   pair: FreeDivisionAlgebra; ratexprInverse

:spadfun:`ratexprInverse`\: (%, \ :ref:`Boolean <l426f6f6c65616e>`\ ) -> \ :ref:`OutputForm <l4f7574707574466f726d>`\  
  \ ``ratexprInverse(f, flg)``\  returns \ ``f``\  in output form if it is a polynomial, (\ ``f``\ )^-1 if \ ``f^``\ -1 is a polynomial, "r<rank>" if the system is minimal and "d<dim>" in general.

.. _l467265654469766973696f6e416c6765627261-7265636970:

\ :ref:`recip <l4d61676d6157697468556e6974-7265636970>`\ \: % -> Union(%, failed) 
  from \ :ref:`MagmaWithUnit <l4d61676d6157697468556e6974>`\ 

.. _l467265654469766973696f6e416c6765627261-726566696e6521:

.. index::
   pair: FreeDivisionAlgebra; refine!

:spadfun:`refine!`\: % -> % 
  \ ``refine!(f)``\  refines \ ``f``\  using non-linear techniques.


.. index::
   pair: FreeDivisionAlgebra; refine!

:spadfun:`refine!`\: (%, \ :ref:`Boolean <l426f6f6c65616e>`\ ) -> % 
  \ ``refine!(f, flg)``\  refines the underlying admissible admissible linear system using simple and linear techniques and if flg=true also non-linear techniques (Groebner basis).

.. _l467265654469766973696f6e416c6765627261-726566696e65643f:

.. index::
   pair: FreeDivisionAlgebra; refined?

:spadfun:`refined?`\: % -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  \ ``refined?(f)``\  is \ ``f``\  represented by a refined ALS?

.. _l467265654469766973696f6e416c6765627261-726566696e656d656e744571756174696f6e73:

.. index::
   pair: FreeDivisionAlgebra; refinementEquations

:spadfun:`refinementEquations`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`Boolean <l426f6f6c65616e>`\ , \ :ref:`Boolean <l426f6f6c65616e>`\ ) -> \ :ref:`List <l4c697374>`\  \ :ref:`Polynomial <l506f6c796e6f6d69616c>`\  F 
  \ ``refinementEquations(f,i_min,i_max,k_rows,flg_u,flg_r)``\  for debugging purposes (interface LINPEN)

.. _l467265654469766973696f6e416c6765627261-726566696e656d656e7447726f65626e6572:

.. index::
   pair: FreeDivisionAlgebra; refinementGroebner

:spadfun:`refinementGroebner`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`Boolean <l426f6f6c65616e>`\ , \ :ref:`Boolean <l426f6f6c65616e>`\ ) -> \ :ref:`List <l4c697374>`\  \ :ref:`Polynomial <l506f6c796e6f6d69616c>`\  F 
  \ ``refinementGroebner(f,i_min,i_max,k_rows,flg_u,flg_r)``\  computes a Groebner basis for the ideal generated by the equations for creating a zero block with \ ``k``\  rows within the pivot block \ ``i_min``\ ..\ ``i_max``\  and conditions to guarantee invertible transformations.

.. _l467265654469766973696f6e416c6765627261-726566696e656d656e74536f6c7665:

.. index::
   pair: FreeDivisionAlgebra; refinementSolve

:spadfun:`refinementSolve`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`Boolean <l426f6f6c65616e>`\ , \ :ref:`Boolean <l426f6f6c65616e>`\ ) -> \ :ref:`List <l4c697374>`\  \ :ref:`List <l4c697374>`\  \ :ref:`Equation <l4571756174696f6e>`\  \ :ref:`Polynomial <l506f6c796e6f6d69616c>`\  F 
  \ ``refinementSolve(f,i_min,i_max,k_rows,flg_u,flg_r)``\  Computes a list of solutions (for the entries in transformation matrices) to create a lower left block of zeros with \ ``k``\  rows in the pivot block \ ``i_min``\ ..\ ``i_max``\ .

.. _l467265654469766973696f6e416c6765627261-726566696e656d656e745472616e73666f726d6174696f6e73:

.. index::
   pair: FreeDivisionAlgebra; refinementTransformations

:spadfun:`refinementTransformations`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`List <l4c697374>`\  \ :ref:`Equation <l4571756174696f6e>`\  \ :ref:`Polynomial <l506f6c796e6f6d69616c>`\  F) -> \ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  F 
  \ ``refinementTransformations(f,i_min,i_max,sol)``\  for debugging purposes (interface LINPEN)

.. _l467265654469766973696f6e416c6765627261-726566696e65555221:

.. index::
   pair: FreeDivisionAlgebra; refineUR!

:spadfun:`refineUR!`\: % -> % 
  \ ``refineUR!(f)``\  uses linear techniques to create upper right blocks of zeros in staircase form (as far as possible).


.. index::
   pair: FreeDivisionAlgebra; refineUR!

:spadfun:`refineUR!`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``refineUR!(f,k)``\  uses linear techniques to create an upper right block of zeros with \ ``k``\  rows (if possible).

.. _l467265654469766973696f6e416c6765627261-726567756c61723f:

.. index::
   pair: FreeDivisionAlgebra; regular?

:spadfun:`regular?`\: % -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  \ ``regular?(f)``\  is \ ``f``\  a regular element?

.. _l467265654469766973696f6e416c6765627261-72656d6f7665526f7773436f6c756d6e73:

.. index::
   pair: FreeDivisionAlgebra; removeRowsColumns

:spadfun:`removeRowsColumns`\: (%, \ :ref:`List <l4c697374>`\  \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`List <l4c697374>`\  \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``removeRowsColumns(f, lst_row, lst_col)``\  returns a new system with the specified rows and columns removed. The number of rows and columns have to be the same!

.. _l467265654469766973696f6e416c6765627261-726570726573656e746174696f6e:

.. index::
   pair: FreeDivisionAlgebra; representation

:spadfun:`representation`\: % -> \ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  \ :ref:`XDistributedPolynomial <l584469737472696275746564506f6c796e6f6d69616c>`\ (VAR, F) 
  \ ``representation(f)``\  returns the element \ ``f``\  as linear representation (\ ``u``\ ,A,\ ``v``\ ).

.. _l467265654469766973696f6e416c6765627261-7269676874466163746f72:

.. index::
   pair: FreeDivisionAlgebra; rightFactor

:spadfun:`rightFactor`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``rightFactor(f,k)``\  returns the right factor of rank \ ``k``\  of a polynomial \ ``f``\  or 1 if it\ ``'s``\  not possible by linear techniques.

.. _l467265654469766973696f6e416c6765627261-726967687446616d696c79:

.. index::
   pair: FreeDivisionAlgebra; rightFamily

:spadfun:`rightFamily`\: % -> \ :ref:`List <l4c697374>`\  \ :ref:`OutputForm <l4f7574707574466f726d>`\  
  \ ``rightFamily(f)``\  prints the right family t=u*A^-1.

.. _l467265654469766973696f6e416c6765627261-72696768744d696e696d697a6174696f6e:

.. index::
   pair: FreeDivisionAlgebra; rightMinimization

:spadfun:`rightMinimization`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``rightMinimization(f, i_min, i_max)``\  tries to apply a right minimization step with respect to the pivot block with the rows/columns (\ ``i_min``\ , ..., i_max).

.. _l467265654469766973696f6e416c6765627261-7269676874506f776572:

\ :ref:`rightPower <l4d61676d6157697468556e6974-7269676874506f776572>`\ \: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  from \ :ref:`MagmaWithUnit <l4d61676d6157697468556e6974>`\ 


\ :ref:`rightPower <l4d61676d61-7269676874506f776572>`\ \: (%, \ :ref:`PositiveInteger <l506f736974697665496e7465676572>`\ ) -> % 
  from \ :ref:`Magma <l4d61676d61>`\ 

.. _l467265654469766973696f6e416c6765627261-72696768745265636970:

\ :ref:`rightRecip <l4d61676d6157697468556e6974-72696768745265636970>`\ \: % -> Union(%, failed) 
  from \ :ref:`MagmaWithUnit <l4d61676d6157697468556e6974>`\ 

.. _l467265654469766973696f6e416c6765627261-726f775370616e:

.. index::
   pair: FreeDivisionAlgebra; rowSpan

:spadfun:`rowSpan`\: % -> \ :ref:`Stream <l53747265616d>`\  \ :ref:`Matrix <l4d6174726978>`\  \ :ref:`XDistributedPolynomial <l584469737472696275746564506f6c796e6f6d69616c>`\ (VAR, F) 
  \ ``rowSpan(f)``\  computes the row span for a regular element, that is (\ ``u``\ ; uM; \ ``uM^2``\ ; ...) where PAs=Pv with PA = \ ``I``\ -\ ``M``\ .

.. _l467265654469766973696f6e416c6765627261-73616d706c65:

\ :ref:`sample <l4162656c69616e4d6f6e6f6964-73616d706c65>`\ \: % 
  from \ :ref:`AbelianMonoid <l4162656c69616e4d6f6e6f6964>`\ 

.. _l467265654469766973696f6e416c6765627261-7363616c61723f:

.. index::
   pair: FreeDivisionAlgebra; scalar?

:spadfun:`scalar?`\: % -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  \ ``scalar?(f)``\  is \ ``f``\  scalar?


.. index::
   pair: FreeDivisionAlgebra; scalar?

:spadfun:`scalar?`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  \ ``scalar?(f, i, j)``\  is A(\ ``i``\ ,\ ``j``\ ) scalar?

.. _l467265654469766973696f6e416c6765627261-7363616c65414c53:

.. index::
   pair: FreeDivisionAlgebra; scaleALS

:spadfun:`scaleALS`\: (%, F) -> % 
  \ ``scaleALS(f, alpha)``\  computes alpha*f by scaling the right hand side of the ALS for \ ``f``\ .

.. _l467265654469766973696f6e416c6765627261-736574656c7421:

.. index::
   pair: FreeDivisionAlgebra; setelt!

:spadfun:`setelt!`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , F) -> F 
  \ ``setelt!(f, i, alpha)``\  sets \ ``v``\ (\ ``i``\ ) = alpha in the ALS of \ ``f``\ .


.. index::
   pair: FreeDivisionAlgebra; setelt!

:spadfun:`setelt!`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`XDistributedPolynomial <l584469737472696275746564506f6c796e6f6d69616c>`\ (VAR, F)) -> \ :ref:`XDistributedPolynomial <l584469737472696275746564506f6c796e6f6d69616c>`\ (VAR, F) 
  \ ``setelt!(f, i, j, p)``\  sets A(\ ``i``\ ,\ ``j``\ ) = \ ``p``\  in the ALS of \ ``f``\  (where \ ``p``\  has degree less equal one) if the system is in polynomial form and j>i.

.. _l467265654469766973696f6e416c6765627261-736574526566696e656421:

.. index::
   pair: FreeDivisionAlgebra; setRefined!

:spadfun:`setRefined!`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``setRefined!(f,max_sze)``\  sets the internal flag if the system is refined (over the ground field) up to the specified block size.

.. _l467265654469766973696f6e416c6765627261-736f6c7574696f6e566563746f72:

.. index::
   pair: FreeDivisionAlgebra; solutionVector

:spadfun:`solutionVector`\: % -> \ :ref:`Matrix <l4d6174726978>`\  \ :ref:`XDistributedPolynomial <l584469737472696275746564506f6c796e6f6d69616c>`\ (VAR, F) 
  \ ``solutionVector(f)``\  computes the solution vector \ ``s``\  of As=v if \ ``f``\  is polynomial.


.. index::
   pair: FreeDivisionAlgebra; solutionVector

:spadfun:`solutionVector`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> \ :ref:`Matrix <l4d6174726978>`\  \ :ref:`XDistributedPolynomial <l584469737472696275746564506f6c796e6f6d69616c>`\ (VAR, F) 
  \ ``solutionVector(f, k)``\  computes the approximated solution vector up to powers \ ``M^k``\  \ ``v'``\  where PAs=Pv=v' with PA = \ ``I``\ -\ ``M``\ .

.. _l467265654469766973696f6e416c6765627261-7375627472616374496643616e:

\ :ref:`subtractIfCan <l43616e63656c6c6174696f6e4162656c69616e4d6f6e6f6964-7375627472616374496643616e>`\ \: (%, %) -> Union(%, failed) 
  from \ :ref:`CancellationAbelianMonoid <l43616e63656c6c6174696f6e4162656c69616e4d6f6e6f6964>`\ 

.. _l467265654469766973696f6e416c6765627261-73756d6d616e6473:

.. index::
   pair: FreeDivisionAlgebra; summands

:spadfun:`summands`\: % -> \ :ref:`List <l4c697374>`\  % 
  \ ``summands(f)``\  analysis the block structure of the system matrix of the ALS of \ ``f``\  to split \ ``f``\  into summands.

.. _l467265654469766973696f6e416c6765627261-73776170436f6c756d6e7321:

.. index::
   pair: FreeDivisionAlgebra; swapColumns!

:spadfun:`swapColumns!`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``swapColumns!(f, i, j)``\  exchanges columns \ ``i``\  and \ ``j``\  in the ALS of \ ``f``\ .

.. _l467265654469766973696f6e416c6765627261-73776170526f777321:

.. index::
   pair: FreeDivisionAlgebra; swapRows!

:spadfun:`swapRows!`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``swapRows!(f, i, j)``\  exchanges rows \ ``i``\  and \ ``j``\  in the ALS of \ ``f``\ .

.. _l467265654469766973696f6e416c6765627261-73776170526f7773436f6c756d6e7321:

.. index::
   pair: FreeDivisionAlgebra; swapRowsColumns!

:spadfun:`swapRowsColumns!`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``swapRowsColumns!(f, i, j)``\  exchanges rows \ ``i``\  and \ ``j``\  and columns \ ``j``\  and \ ``i``\  in the ALS of \ ``f``\ .

.. _l467265654469766973696f6e416c6765627261-746f67676c65416c7465726e61746976654f7574707574:

.. index::
   pair: FreeDivisionAlgebra; toggleAlternativeOutput

:spadfun:`toggleAlternativeOutput`\: % -> % 
  \ ``toggleAlternativeOutput(f)``\  enable/disable output as rational expression.

.. _l467265654469766973696f6e416c6765627261-746f67676c6544656275674f7574707574:

.. index::
   pair: FreeDivisionAlgebra; toggleDebugOutput

:spadfun:`toggleDebugOutput`\: % -> % 
  \ ``toggleDebugOutput(f)``\  enable/disable ALS.

.. _l467265654469766973696f6e416c6765627261-7472616e73666f726d6174696f6e4d6174726978:

.. index::
   pair: FreeDivisionAlgebra; transformationMatrix

:spadfun:`transformationMatrix`\: % -> \ :ref:`Matrix <l4d6174726978>`\  F 
  \ ``transformationMatrix(f)``\  returns the identity matrix to be modified and used within transformRows! or transformColumns!

.. _l467265654469766973696f6e416c6765627261-7472616e73666f726d436f6c756d6e7321:

.. index::
   pair: FreeDivisionAlgebra; transformColumns!

:spadfun:`transformColumns!`\: (%, \ :ref:`Matrix <l4d6174726978>`\  F) -> % 
  \ ``transformColumns!(f, U)``\  transforms the ALS of \ ``f``\  from the right.

.. _l467265654469766973696f6e416c6765627261-7472616e73666f726d526f777321:

.. index::
   pair: FreeDivisionAlgebra; transformRows!

:spadfun:`transformRows!`\: (%, \ :ref:`Matrix <l4d6174726978>`\  F) -> % 
  \ ``transformRows!(f, T)``\  transforms the ALS of \ ``f``\  from the left.

.. _l467265654469766973696f6e416c6765627261-756e69743f:

\ :ref:`unit? <l456e7469726552696e67-756e69743f>`\ \: % -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  from \ :ref:`EntireRing <l456e7469726552696e67>`\ 

.. _l467265654469766973696f6e416c6765627261-756e697443616e6f6e6963616c:

\ :ref:`unitCanonical <l456e7469726552696e67-756e697443616e6f6e6963616c>`\ \: % -> % 
  from \ :ref:`EntireRing <l456e7469726552696e67>`\ 

.. _l467265654469766973696f6e416c6765627261-756e69744e6f726d616c:

\ :ref:`unitNormal <l456e7469726552696e67-756e69744e6f726d616c>`\ \: % -> Record(unit: %, canonical: %, associate: %) 
  from \ :ref:`EntireRing <l456e7469726552696e67>`\ 

.. _l467265654469766973696f6e416c6765627261-7661726961626c6573:

.. index::
   pair: FreeDivisionAlgebra; variables

:spadfun:`variables`\: % -> \ :ref:`List <l4c697374>`\  \ :ref:`FreeMonoid <l467265654d6f6e6f6964>`\  VAR 
  \ ``variables(f)``\  returns a list of the variables.

.. _l467265654469766973696f6e416c6765627261-766563746f72:

.. index::
   pair: FreeDivisionAlgebra; vector

:spadfun:`vector`\: % -> \ :ref:`Matrix <l4d6174726978>`\  F 
  \ ``vector(f)``\  returns \ ``v``\  from the ALS of \ ``f``\ .


.. index::
   pair: FreeDivisionAlgebra; vector

:spadfun:`vector`\: % -> \ :ref:`Matrix <l4d6174726978>`\  \ :ref:`XDistributedPolynomial <l584469737472696275746564506f6c796e6f6d69616c>`\ (VAR, F) 
  \ ``vector(f)``\  returns \ ``v``\  from the ALS of \ ``f``\ .

.. _l467265654469766973696f6e416c6765627261-7a65726f3f:

\ :ref:`zero? <l4162656c69616e4d6f6e6f6964-7a65726f3f>`\ \: % -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  from \ :ref:`AbelianMonoid <l4162656c69616e4d6f6e6f6964>`\ 


.. index::
   pair: FreeDivisionAlgebra; zero?

:spadfun:`zero?`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ , \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  \ ``zero?(f, i, j)``\  is A(\ ``i``\ ,\ ``j``\ ) zero?


\ :ref:`AbelianGroup <l4162656c69616e47726f7570>`\  

\ :ref:`AbelianMonoid <l4162656c69616e4d6f6e6f6964>`\  

\ :ref:`AbelianSemiGroup <l4162656c69616e53656d6947726f7570>`\  

\ :ref:`Algebra <l416c6765627261>`\  F 

\ :ref:`Algebra <l416c6765627261>`\  \ :ref:`Fraction <l4672616374696f6e>`\  \ :ref:`Integer <l496e7465676572>`\  

\ :ref:`BasicType <l426173696354797065>`\  

\ :ref:`BiModule <l42694d6f64756c65>`\ (%, %) 

\ :ref:`BiModule <l42694d6f64756c65>`\ (F, F) 

\ :ref:`BiModule <l42694d6f64756c65>`\ (\ :ref:`Fraction <l4672616374696f6e>`\  \ :ref:`Integer <l496e7465676572>`\ , \ :ref:`Fraction <l4672616374696f6e>`\  \ :ref:`Integer <l496e7465676572>`\ ) 

\ :ref:`CancellationAbelianMonoid <l43616e63656c6c6174696f6e4162656c69616e4d6f6e6f6964>`\  

\ :ref:`CoercibleTo <l436f65726369626c65546f>`\  \ :ref:`OutputForm <l4f7574707574466f726d>`\  

\ :ref:`DivisionRing <l4469766973696f6e52696e67>`\  

\ :ref:`EntireRing <l456e7469726552696e67>`\  

\ :ref:`LeftModule <l4c6566744d6f64756c65>`\  % 

\ :ref:`LeftModule <l4c6566744d6f64756c65>`\  F 

\ :ref:`LeftModule <l4c6566744d6f64756c65>`\  \ :ref:`Fraction <l4672616374696f6e>`\  \ :ref:`Integer <l496e7465676572>`\  

\ :ref:`Magma <l4d61676d61>`\  

\ :ref:`MagmaWithUnit <l4d61676d6157697468556e6974>`\  

\ :ref:`Module <l4d6f64756c65>`\  F 

\ :ref:`Module <l4d6f64756c65>`\  \ :ref:`Fraction <l4672616374696f6e>`\  \ :ref:`Integer <l496e7465676572>`\  

\ :ref:`Monoid <l4d6f6e6f6964>`\  

\ :ref:`NonAssociativeAlgebra <l4e6f6e4173736f63696174697665416c6765627261>`\  F 

\ :ref:`NonAssociativeAlgebra <l4e6f6e4173736f63696174697665416c6765627261>`\  \ :ref:`Fraction <l4672616374696f6e>`\  \ :ref:`Integer <l496e7465676572>`\  

\ :ref:`NonAssociativeRing <l4e6f6e4173736f6369617469766552696e67>`\  

\ :ref:`NonAssociativeRng <l4e6f6e4173736f63696174697665526e67>`\  

\ :ref:`NonAssociativeSemiRing <l4e6f6e4173736f6369617469766553656d6952696e67>`\  

\ :ref:`NonAssociativeSemiRng <l4e6f6e4173736f6369617469766553656d69526e67>`\  

\ :ref:`noZeroDivisors <l6e6f5a65726f44697669736f7273>`\  

\ :ref:`RightModule <l52696768744d6f64756c65>`\  % 

\ :ref:`RightModule <l52696768744d6f64756c65>`\  F 

\ :ref:`RightModule <l52696768744d6f64756c65>`\  \ :ref:`Fraction <l4672616374696f6e>`\  \ :ref:`Integer <l496e7465676572>`\  

\ :ref:`Ring <l52696e67>`\  

\ :ref:`Rng <l526e67>`\  

\ :ref:`SemiGroup <l53656d6947726f7570>`\  

\ :ref:`SemiRing <l53656d6952696e67>`\  

\ :ref:`SemiRng <l53656d69526e67>`\  

\ :ref:`SetCategory <l53657443617465676f7279>`\  

\ :ref:`TwoSidedRecip <l54776f53696465645265636970>`\  

\ :ref:`unitsKnown <l756e6974734b6e6f776e>`\  

