.. index:: PolynomialIdeal

.. _l506f6c796e6f6d69616c496465616c:

PolynomialIdeal(F, Expon, VarSet, DPoly)
========================================

:viewcode:`ideal.spad line 1 <ideal.spad#L1>` :editcode:`[edit on github] <ideal.spad#L1>`

* F: \ :ref:`Field <l4669656c64>`\ 

* Expon: \ :ref:`OrderedAbelianMonoidSup <l4f7264657265644162656c69616e4d6f6e6f6964537570>`\ 

* VarSet: \ :ref:`OrderedSet <l4f726465726564536574>`\ 

* DPoly: \ :ref:`PolynomialCategory <l506f6c796e6f6d69616c43617465676f7279>`\ (F, Expon, VarSet)


This domain represents polynomial ideals with coefficients in any field and supports the basic ideal operations, including intersection, sum and quotient. An ideal is represented by a list of polynomials (the generators of the ideal) and a boolean that is \ ``true``\  if the generators are a Groebner basis. The algorithms used are based on Groebner basis computations. The ordering is determined by the datatype of the input polynomials. Users may use refinements of total degree orderings.


.. _l506f6c796e6f6d69616c496465616c-2a:

.. index::
   pair: PolynomialIdeal; *

:spadfun:`\*`\: (%, %) -> % 
  \ ``I*J``\  computes the product of the ideal \ ``I``\  and \ ``J``\ .

.. _l506f6c796e6f6d69616c496465616c-2b:

.. index::
   pair: PolynomialIdeal; +

:spadfun:`+`\: (%, %) -> % 
  \ ``I+J``\  computes the ideal generated by the union of \ ``I``\  and \ ``J``\ .

.. _l506f6c796e6f6d69616c496465616c-3d:

\ :ref:`= <l426173696354797065-3d>`\ \: (%, %) -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  from \ :ref:`BasicType <l426173696354797065>`\ 

.. _l506f6c796e6f6d69616c496465616c-5e:

.. index::
   pair: PolynomialIdeal; ^

:spadfun:`^`\: (%, \ :ref:`NonNegativeInteger <l4e6f6e4e65676174697665496e7465676572>`\ ) -> % 
  \ ``I^n``\  computes the \ ``n``\ th power of the ideal \ ``I``\ .

.. _l506f6c796e6f6d69616c496465616c-7e3d:

\ :ref:`~= <l426173696354797065-7e3d>`\ \: (%, %) -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  from \ :ref:`BasicType <l426173696354797065>`\ 

.. _l506f6c796e6f6d69616c496465616c-6261636b4f6c64506f73:

.. index::
   pair: PolynomialIdeal; backOldPos

:spadfun:`backOldPos`\: Record(mval: \ :ref:`Matrix <l4d6174726978>`\  F, invmval: \ :ref:`Matrix <l4d6174726978>`\  F, genIdeal: %) -> % 
  \ ``backOldPos(genPos)``\  takes the result produced by \ :ref:`generalPosition <l506f6c796e6f6d69616c496465616c-67656e6572616c506f736974696f6e>`\  and performs the inverse transformation, returning the original ideal \ ``backOldPos(generalPosition(I, listvar))``\  = \ ``I``\ .

.. _l506f6c796e6f6d69616c496465616c-636f65726365:

\ :ref:`coerce <l436f65726369626c65546f-636f65726365>`\ \: % -> \ :ref:`OutputForm <l4f7574707574466f726d>`\  
  from \ :ref:`CoercibleTo <l436f65726369626c65546f>`\  \ :ref:`OutputForm <l4f7574707574466f726d>`\ 


.. index::
   pair: PolynomialIdeal; coerce

:spadfun:`coerce`\: \ :ref:`List <l4c697374>`\  DPoly -> % 
  \ ``coerce(polyList)``\  converts the list of polynomials \ ``polyList``\  to an ideal.

.. _l506f6c796e6f6d69616c496465616c-64696d656e73696f6e:

.. index::
   pair: PolynomialIdeal; dimension

:spadfun:`dimension`\: % -> \ :ref:`Integer <l496e7465676572>`\  
  \ ``dimension(I)``\  gives the dimension of the ideal \ ``I``\ . in the ring \ ``F[lvar]``\ , where lvar are the variables appearing in \ ``I``\ 


.. index::
   pair: PolynomialIdeal; dimension

:spadfun:`dimension`\: (%, \ :ref:`List <l4c697374>`\  VarSet) -> \ :ref:`Integer <l496e7465676572>`\  
  \ ``dimension(I, lvar)``\  gives the dimension of the ideal \ ``I``\ , in the ring \ ``F[lvar]``\ 

.. _l506f6c796e6f6d69616c496465616c-656c656d656e743f:

.. index::
   pair: PolynomialIdeal; element?

:spadfun:`element?`\: (DPoly, %) -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  \ ``element?(f, I)``\  tests whether the polynomial \ ``f``\  belongs to the ideal \ ``I``\ .

.. _l506f6c796e6f6d69616c496465616c-67656e6572616c506f736974696f6e:

.. index::
   pair: PolynomialIdeal; generalPosition

:spadfun:`generalPosition`\: (%, \ :ref:`List <l4c697374>`\  VarSet) -> Record(mval: \ :ref:`Matrix <l4d6174726978>`\  F, invmval: \ :ref:`Matrix <l4d6174726978>`\  F, genIdeal: %) 
  \ ``generalPosition(I, listvar)``\  perform a random linear transformation on the variables in listvar and returns the transformed ideal along with the change of basis matrix.

.. _l506f6c796e6f6d69616c496465616c-67656e657261746f7273:

.. index::
   pair: PolynomialIdeal; generators

:spadfun:`generators`\: % -> \ :ref:`List <l4c697374>`\  DPoly 
  \ ``generators(I)``\  returns a list of generators for the ideal \ ``I``\ .

.. _l506f6c796e6f6d69616c496465616c-67726f65626e65723f:

.. index::
   pair: PolynomialIdeal; groebner?

:spadfun:`groebner?`\: % -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  \ ``groebner?(I)``\  tests if the generators of the ideal \ ``I``\  are a Groebner basis.

.. _l506f6c796e6f6d69616c496465616c-67726f65626e6572:

.. index::
   pair: PolynomialIdeal; groebner

:spadfun:`groebner`\: % -> % 
  \ ``groebner(I)``\  returns a set of generators of \ ``I``\  that are a Groebner basis for \ ``I``\ .

.. _l506f6c796e6f6d69616c496465616c-67726f65626e6572496465616c:

.. index::
   pair: PolynomialIdeal; groebnerIdeal

:spadfun:`groebnerIdeal`\: \ :ref:`List <l4c697374>`\  DPoly -> % 
  \ ``groebnerIdeal(polyList)``\  constructs the ideal generated by the list of polynomials \ ``polyList``\  which are assumed to be a Groebner basis. Note: this operation avoids a Groebner basis computation.

.. _l506f6c796e6f6d69616c496465616c-696465616c:

.. index::
   pair: PolynomialIdeal; ideal

:spadfun:`ideal`\: \ :ref:`List <l4c697374>`\  DPoly -> % 
  \ ``ideal(polyList)``\  constructs the ideal generated by the list of polynomials \ ``polyList``\ .

.. _l506f6c796e6f6d69616c496465616c-696e3f:

.. index::
   pair: PolynomialIdeal; in?

:spadfun:`in?`\: (%, %) -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  \ ``in?(I, J)``\  tests if the ideal \ ``I``\  is contained in the ideal \ ``J``\ .

.. _l506f6c796e6f6d69616c496465616c-696e5261646963616c3f:

.. index::
   pair: PolynomialIdeal; inRadical?

:spadfun:`inRadical?`\: (DPoly, %) -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  \ ``inRadical?(f, I)``\  tests if some power of the polynomial \ ``f``\  belongs to the ideal \ ``I``\ .

.. _l506f6c796e6f6d69616c496465616c-696e74657273656374:

.. index::
   pair: PolynomialIdeal; intersect

:spadfun:`intersect`\: (%, %) -> % 
  \ ``intersect(I, J)``\  computes the intersection of the ideals \ ``I``\  and \ ``J``\ .


.. index::
   pair: PolynomialIdeal; intersect

:spadfun:`intersect`\: \ :ref:`List <l4c697374>`\  % -> % 
  \ ``intersect(LI)``\  computes the intersection of the list of ideals \ ``LI``\ .

.. _l506f6c796e6f6d69616c496465616c-6c61746578:

\ :ref:`latex <l53657443617465676f7279-6c61746578>`\ \: % -> \ :ref:`String <l537472696e67>`\  
  from \ :ref:`SetCategory <l53657443617465676f7279>`\ 

.. _l506f6c796e6f6d69616c496465616c-6c656164696e67496465616c:

.. index::
   pair: PolynomialIdeal; leadingIdeal

:spadfun:`leadingIdeal`\: % -> % 
  \ ``leadingIdeal(I)``\  is the ideal generated by the leading terms of the elements of the ideal \ ``I``\ .

.. _l506f6c796e6f6d69616c496465616c-6f6e653f:

.. index::
   pair: PolynomialIdeal; one?

:spadfun:`one?`\: % -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  \ ``one?(I)``\  tests whether the ideal \ ``I``\  is the unit ideal, i.e. contains 1.

.. _l506f6c796e6f6d69616c496465616c-71756f7469656e74:

.. index::
   pair: PolynomialIdeal; quotient

:spadfun:`quotient`\: (%, %) -> % 
  \ ``quotient(I, J)``\  computes the quotient of the ideals \ ``I``\  and \ ``J``\ , \ ``(I: J)``\ .


.. index::
   pair: PolynomialIdeal; quotient

:spadfun:`quotient`\: (%, DPoly) -> % 
  \ ``quotient(I, f)``\  computes the quotient of the ideal \ ``I``\  by the principal ideal generated by the polynomial \ ``f``\ , \ ``(I: (f))``\ .

.. _l506f6c796e6f6d69616c496465616c-72656c6174696f6e73496465616c:

.. index::
   pair: PolynomialIdeal; relationsIdeal

:spadfun:`relationsIdeal`\: \ :ref:`List <l4c697374>`\  DPoly -> \ :ref:`SuchThat <l5375636854686174>`\ (\ :ref:`List <l4c697374>`\  \ :ref:`Polynomial <l506f6c796e6f6d69616c>`\  F, \ :ref:`List <l4c697374>`\  \ :ref:`Equation <l4571756174696f6e>`\  \ :ref:`Polynomial <l506f6c796e6f6d69616c>`\  F) if VarSet has \ :ref:`ConvertibleTo <l436f6e7665727469626c65546f>`\  \ :ref:`Symbol <l53796d626f6c>`\ 
  \ ``relationsIdeal(polyList)``\  returns the ideal of relations among the polynomials in \ ``polyList``\ .

.. _l506f6c796e6f6d69616c496465616c-7361747572617465:

.. index::
   pair: PolynomialIdeal; saturate

:spadfun:`saturate`\: (%, DPoly) -> % 
  \ ``saturate(I, f)``\  is the saturation of the ideal \ ``I``\  with respect to the multiplicative set generated by the polynomial \ ``f``\ .


.. index::
   pair: PolynomialIdeal; saturate

:spadfun:`saturate`\: (%, DPoly, \ :ref:`List <l4c697374>`\  VarSet) -> % 
  \ ``saturate(I, f, lvar)``\  is the saturation with respect to the prime principal ideal which is generated by \ ``f``\  in the polynomial ring \ ``F[lvar]``\ .

.. _l506f6c796e6f6d69616c496465616c-7a65726f3f:

.. index::
   pair: PolynomialIdeal; zero?

:spadfun:`zero?`\: % -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  \ ``zero?(I)``\  tests whether the ideal \ ``I``\  is the zero ideal

.. _l506f6c796e6f6d69616c496465616c-7a65726f44696d3f:

.. index::
   pair: PolynomialIdeal; zeroDim?

:spadfun:`zeroDim?`\: % -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  \ ``zeroDim?(I)``\  tests if the ideal \ ``I``\  is zero dimensional, i.e. all its associated primes are maximal, in the ring \ ``F[lvar]``\ , where lvar are the variables appearing in \ ``I``\ 


.. index::
   pair: PolynomialIdeal; zeroDim?

:spadfun:`zeroDim?`\: (%, \ :ref:`List <l4c697374>`\  VarSet) -> \ :ref:`Boolean <l426f6f6c65616e>`\  
  \ ``zeroDim?(I, lvar)``\  tests if the ideal \ ``I``\  is zero dimensional, i.e. all its associated primes are maximal, in the ring \ ``F[lvar]``\ 


\ :ref:`BasicType <l426173696354797065>`\  

\ :ref:`CoercibleTo <l436f65726369626c65546f>`\  \ :ref:`OutputForm <l4f7574707574466f726d>`\  

\ :ref:`SetCategory <l53657443617465676f7279>`\  

