.. index:: RepresentationPackage2

.. _l526570726573656e746174696f6e5061636b61676532:

RepresentationPackage2 R
========================

:viewcode:`rep2.spad line 1 <rep2.spad#L1>` :editcode:`[edit on github] <rep2.spad#L1>`

* R: \ :ref:`Ring <l52696e67>`\ 


\ ``RepresentationPackage2``\  provides functions for working with modular representations of finite groups and algebra. The routines in this package are created, using ideas of \ ``R``\ . Parker, (the meat-Axe) to get smaller representations from bigger ones, i.e. finding sub- and factormodules, or to show, that such the representations are irreducible. Note: most functions are randomized functions of Las Vegas type i.e. every answer is correct, but with small probability the algorithm fails to get an answer.


.. _l526570726573656e746174696f6e5061636b61676532-6172654571756976616c656e743f:

.. index::
   pair: RepresentationPackage2; areEquivalent?

:spadfun:`areEquivalent?`\: (\ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  R, \ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  R) -> \ :ref:`Matrix <l4d6174726978>`\  R if R has \ :ref:`Field <l4669656c64>`\ 
  \ ``areEquivalent?(aG0, aG1)``\  calls \ *areEquivalent?(aG0, aG1, true, 25)*\ . Note: the choice of 25 was rather arbitrary.


.. index::
   pair: RepresentationPackage2; areEquivalent?

:spadfun:`areEquivalent?`\: (\ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  R, \ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  R, \ :ref:`Boolean <l426f6f6c65616e>`\ , \ :ref:`Integer <l496e7465676572>`\ ) -> \ :ref:`Matrix <l4d6174726978>`\  R if R has \ :ref:`Field <l4669656c64>`\ 
  \ ``areEquivalent?(aG0, aG1, randomelements, numberOfTries)``\  tests whether the two lists of matrices, all assumed of same square shape, can be simultaneously conjugated by a non-singular matrix. If these matrices represent the same group generators, the representations are equivalent. The algorithm tries \ *numberOfTries*\  times to create elements in the generated algebras in the same fashion. If their ranks differ, they are not equivalent. If an isomorphism is assumed, then the kernel of an element of the first algebra is mapped to the kernel of the corresponding element in the second algebra. Now consider the one-dimensional ones. If they generate the whole space (e.g. irreducibility !) we use \ *standardBasisOfCyclicSubmodule*\  to create the only possible transition matrix. The method checks whether the matrix conjugates all corresponding matrices from \ *aGi*\ . The way to choose the singular matrices is as in \ *meatAxe*\ . If the two representations are equivalent, this routine returns the transformation matrix \ *TM*\  with \ *aG0.i * TM = TM * aG1.i*\  for all \ ``i``\ . If the representations are not equivalent, a small 0-matrix is returned. Note: the case with different sets of group generators cannot be handled.


.. index::
   pair: RepresentationPackage2; areEquivalent?

:spadfun:`areEquivalent?`\: (\ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  R, \ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  R, \ :ref:`Integer <l496e7465676572>`\ ) -> \ :ref:`Matrix <l4d6174726978>`\  R if R has \ :ref:`Field <l4669656c64>`\ 
  \ ``areEquivalent?(aG0, aG1, numberOfTries)``\  calls \ *areEquivalent?(aG0, aG1, true, 25)*\ . Note: the choice of 25 was rather arbitrary.

.. _l526570726573656e746174696f6e5061636b61676532-636f6d706c657465456368656c6f6e4261736973:

.. index::
   pair: RepresentationPackage2; completeEchelonBasis

:spadfun:`completeEchelonBasis`\: \ :ref:`Vector <l566563746f72>`\  \ :ref:`Vector <l566563746f72>`\  R -> \ :ref:`Matrix <l4d6174726978>`\  R 
  \ ``completeEchelonBasis(lv)``\  completes the basis \ *lv*\  assumed to be in echelon form of a subspace of \ *R^n*\  (\ ``n``\  the length of all the vectors in \ *lv*\ ) with unit vectors to a basis of \ *R^n*\ . It is assumed that the argument is not an empty vector and that it is not the basis of the 0-subspace. Note: the rows of the result correspond to the vectors of the basis.

.. _l526570726573656e746174696f6e5061636b61676532-63726561746552616e646f6d456c656d656e74:

.. index::
   pair: RepresentationPackage2; createRandomElement

:spadfun:`createRandomElement`\: (\ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  R, \ :ref:`Matrix <l4d6174726978>`\  R) -> \ :ref:`Matrix <l4d6174726978>`\  R 
  \ ``createRandomElement(aG, x)``\  creates a random element of the group algebra generated by \ *aG*\ .

.. _l526570726573656e746174696f6e5061636b61676532-6379636c69635375626d6f64756c65:

.. index::
   pair: RepresentationPackage2; cyclicSubmodule

:spadfun:`cyclicSubmodule`\: (\ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  R, \ :ref:`Vector <l566563746f72>`\  R) -> \ :ref:`Vector <l566563746f72>`\  \ :ref:`Vector <l566563746f72>`\  R if R has \ :ref:`EuclideanDomain <l4575636c696465616e446f6d61696e>`\ 
  \ ``cyclicSubmodule(lm, v)``\  generates a basis as follows. It is assumed that the size \ ``n``\  of the vector equals the number of rows and columns of the matrices. Then the matrices generate a subalgebra, say \ ``A``\ , of the algebra of all square matrices of dimension \ ``n``\ . \ *V R*\  is an \ ``A``\ -module in the natural way. cyclicSubmodule(\ ``lm``\ , \ ``v``\ ) generates the \ ``R``\ -Basis of \ *Av*\  as described in section 6 of \ ``R``\ . A. Parker\ ``'s``\  "The Meat-Axe". Note: in contrast to the description in "The Meat-Axe" and to \ *standardBasisOfCyclicSubmodule*\  the result is in echelon form.

.. _l526570726573656e746174696f6e5061636b61676532-69734162736f6c7574656c794972726564756369626c653f:

.. index::
   pair: RepresentationPackage2; isAbsolutelyIrreducible?

:spadfun:`isAbsolutelyIrreducible?`\: (\ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  R, \ :ref:`Integer <l496e7465676572>`\ ) -> \ :ref:`Boolean <l426f6f6c65616e>`\  if R has \ :ref:`Field <l4669656c64>`\ 
  \ ``isAbsolutelyIrreducible?(aG, numberOfTries)``\  uses Norton\ ``'s``\  irreducibility test to check for absolute irreduciblity, assuming if a one-dimensional kernel is found. As no field extension changes create "new" elements in a one-dimensional space, the criterium stays \ ``true``\  for every extension. The method looks for one-dimensionals only by creating random elements (no fingerprints) since a run of \ *meatAxe*\  would have proved absolute irreducibility anyway.


.. index::
   pair: RepresentationPackage2; isAbsolutelyIrreducible?

:spadfun:`isAbsolutelyIrreducible?`\: \ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  R -> \ :ref:`Boolean <l426f6f6c65616e>`\  if R has \ :ref:`Field <l4669656c64>`\ 
  \ ``isAbsolutelyIrreducible?(aG)``\  calls \ *isAbsolutelyIrreducible?(aG, 25)*\ . Note: the choice of 25 was rather arbitrary.

.. _l526570726573656e746174696f6e5061636b61676532-6d656174417865:

.. index::
   pair: RepresentationPackage2; meatAxe

:spadfun:`meatAxe`\: (\ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  R, \ :ref:`Boolean <l426f6f6c65616e>`\ ) -> \ :ref:`List <l4c697374>`\  \ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  R if R has \ :ref:`Field <l4669656c64>`\  and R has \ :ref:`Finite <l46696e697465>`\ 
  \ ``meatAxe(aG, randomElements)``\  calls \ *meatAxe(aG, false, 6, 7)*\ , only using Parker\ ``'s``\  fingerprints, if \ *randomElemnts*\  is \ ``false``\ . If it is \ ``true``\ , it calls \ *meatAxe(aG, true, 25, 7)*\ , only using random elements. Note: the choice of 25 was rather arbitrary. Also, 7 covers the case of three-dimensional kernels over the field with 2 elements.


.. index::
   pair: RepresentationPackage2; meatAxe

:spadfun:`meatAxe`\: (\ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  R, \ :ref:`Boolean <l426f6f6c65616e>`\ , \ :ref:`Integer <l496e7465676572>`\ , \ :ref:`Integer <l496e7465676572>`\ ) -> \ :ref:`List <l4c697374>`\  \ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  R if R has \ :ref:`Field <l4669656c64>`\  and R has \ :ref:`Finite <l46696e697465>`\ 
  \ ``meatAxe(aG, randomElements, numberOfTries, maxTests)``\  returns a 2-list of representations as follows. All matrices of argument \ ``aG``\  are assumed to be square and of equal size. Then \ ``aG``\  generates a subalgebra, say \ ``A``\ , of the algebra of all square matrices of dimension \ ``n``\ . \ *V R*\  is an A-module in the usual way. meatAxe(\ ``aG``\ , \ ``numberOfTries``\ , maxTests) creates at most \ *numberOfTries*\  random elements of the algebra, tests them for singularity. If singular, it tries at most \ *maxTests*\  elements of its kernel to generate a proper submodule. If successful, a 2-list is returned: first, a list containing first the list of the representations of the submodule, then a list of the representations of the factor module. Otherwise, if we know that all the kernel is already scanned, Norton\ ``'s``\  irreducibility test can be used either to prove irreducibility or to find the splitting. If \ *randomElements*\  is \ *false*\ , the first 6 tries use Parker\ ``'s``\  fingerprints.


.. index::
   pair: RepresentationPackage2; meatAxe

:spadfun:`meatAxe`\: (\ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  R, \ :ref:`PositiveInteger <l506f736974697665496e7465676572>`\ ) -> \ :ref:`List <l4c697374>`\  \ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  R if R has \ :ref:`Field <l4669656c64>`\  and R has \ :ref:`Finite <l46696e697465>`\ 
  \ ``meatAxe(aG, numberOfTries)``\  calls \ *meatAxe(aG, true, numberOfTries, 7)*\ . Notes: 7 covers the case of three-dimensional kernels over the field with 2 elements.


.. index::
   pair: RepresentationPackage2; meatAxe

:spadfun:`meatAxe`\: \ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  R -> \ :ref:`List <l4c697374>`\  \ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  R if R has \ :ref:`Field <l4669656c64>`\  and R has \ :ref:`Finite <l46696e697465>`\ 
  \ ``meatAxe(aG)``\  calls \ *meatAxe(aG, false, 25, 7)*\  returns a 2-list of representations as follows. All matrices of argument \ ``aG``\  are assumed to be square and of equal size. Then \ ``aG``\  generates a subalgebra, say \ ``A``\ , of the algebra of all square matrices of dimension \ ``n``\ . \ *V R*\  is an A-module in the usual way. meatAxe(\ ``aG``\ ) creates at most 25 random elements of the algebra, tests them for singularity. If singular, it tries at most 7 elements of its kernel to generate a proper submodule. If successful a list which contains first the list of the representations of the submodule, then a list of the representations of the factor module is returned. Otherwise, if we know that all the kernel is already scanned, Norton\ ``'s``\  irreducibility test can be used either to prove irreducibility or to find the splitting. Notes: the first 6 tries use Parker\ ``'s``\  fingerprints. Also, 7 covers the case of three-dimensional kernels over the field with 2 elements.

.. _l526570726573656e746174696f6e5061636b61676532-7363616e4f6e6544696d537562737061636573:

.. index::
   pair: RepresentationPackage2; scanOneDimSubspaces

:spadfun:`scanOneDimSubspaces`\: (\ :ref:`List <l4c697374>`\  \ :ref:`Vector <l566563746f72>`\  R, \ :ref:`Integer <l496e7465676572>`\ ) -> \ :ref:`Vector <l566563746f72>`\  R if R has \ :ref:`Field <l4669656c64>`\  and R has \ :ref:`Finite <l46696e697465>`\ 
  \ ``scanOneDimSubspaces(basis, n)``\  gives a canonical representative of the \ *n*\ \ ``-``\ th one-dimensional subspace of the vector space generated by the elements of \ *basis*\ , all from \ *R^n*\ . The coefficients of the representative are of shape \ *(0, ..., 0, 1, *, ..., *)*\ , \ ***\  in \ ``R``\ . If the size of \ ``R``\  is \ ``q``\ , then there are \ *(q^n-1)/(q-1)*\  of them. We first reduce \ ``n``\  modulo this number, then find the largest \ ``i``\  such that \ *+/[q^i for i in 0..i-1] <= n*\ . Subtracting this sum of powers from \ ``n``\  results in an \ ``i``\ -digit number to \ ``basis``\  \ ``q``\ . This fills the positions of the stars.

.. _l526570726573656e746174696f6e5061636b61676532-73706c6974:

.. index::
   pair: RepresentationPackage2; split

:spadfun:`split`\: (\ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  R, \ :ref:`Vector <l566563746f72>`\  R) -> \ :ref:`List <l4c697374>`\  \ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  R if R has \ :ref:`Field <l4669656c64>`\ 
  \ ``split(aG, vector)``\  returns a subalgebra \ ``A``\  of all square matrix of dimension \ ``n``\  as a list of list of matrices, generated by the list of matrices \ ``aG``\ , where \ ``n``\  denotes both the size of vector as well as the dimension of each of the square matrices. \ *V R*\  is an A-module in the natural way. split(\ ``aG``\ , vector) then checks whether the cyclic submodule generated by \ *vector*\  is a proper submodule of \ *V R*\ . If successful, it returns a two-element list, which contains first the list of the representations of the submodule, then the list of the representations of the factor module. If the vector generates the whole module, a one-element list of the old representation is given. Note: a later version this should call the other split.


.. index::
   pair: RepresentationPackage2; split

:spadfun:`split`\: (\ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  R, \ :ref:`Vector <l566563746f72>`\  \ :ref:`Vector <l566563746f72>`\  R) -> \ :ref:`List <l4c697374>`\  \ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  R if R has \ :ref:`Field <l4669656c64>`\ 
  \ ``split(aG, submodule)``\  uses a proper submodule of \ *R^n*\  to create the representations of the submodule and of the factor module.

.. _l526570726573656e746174696f6e5061636b61676532-7374616e6461726442617369734f664379636c69635375626d6f64756c65:

.. index::
   pair: RepresentationPackage2; standardBasisOfCyclicSubmodule

:spadfun:`standardBasisOfCyclicSubmodule`\: (\ :ref:`List <l4c697374>`\  \ :ref:`Matrix <l4d6174726978>`\  R, \ :ref:`Vector <l566563746f72>`\  R) -> \ :ref:`Matrix <l4d6174726978>`\  R if R has \ :ref:`EuclideanDomain <l4575636c696465616e446f6d61696e>`\ 
  \ ``standardBasisOfCyclicSubmodule(lm, v)``\  returns a matrix as follows. It is assumed that the size \ ``n``\  of the vector equals the number of rows and columns of the matrices. Then the matrices generate a subalgebra, say \ ``A``\ , of the algebra of all square matrices of dimension \ ``n``\ . \ *V R*\  is an \ ``A``\ -module in the natural way. standardBasisOfCyclicSubmodule(\ ``lm``\ , \ ``v``\ ) calculates a matrix whose non-zero column vectors are the \ ``R``\ -Basis of \ *Av*\  achieved in the way as described in section 6 of \ ``R``\ . A. Parker\ ``'s``\  "The Meat-Axe". Note: in contrast to \ *cyclicSubmodule*\ , the result is not in echelon form.


